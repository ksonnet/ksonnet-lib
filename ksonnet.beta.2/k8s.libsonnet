// AUTOGENERATED from the Kubernetes OpenAPI specification. DO NOT MODIFY.
// Kubernetes version: v1.7.0
// SHA of ksonnet-lib HEAD: ca075e30f26b01bb47101cd33b4783f8bfbeaf2b
// SHA of Kubernetes HEAD OpenAPI spec is generated from: a8bff0ed9a153a0eaa84d9995920eeda070cd857

{
  apps:: {
    v1beta1:: {
      local apiVersion = {apiVersion: "apps/v1beta1"},
      // Deployment enables declarative updates for Pods and ReplicaSets.
      deployment:: {
        local kind = {kind: "Deployment"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior of the Deployment.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
            minReadySeconds(minReadySeconds):: __specMixin({minReadySeconds: minReadySeconds}),
            // Indicates that the deployment is paused.
            paused(paused):: __specMixin({paused: paused}),
            // The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Once autoRollback is implemented, the deployment controller will automatically rollback failed deployments. Note that progress will not be estimated during the time a deployment is paused. Defaults to 600s.
            progressDeadlineSeconds(progressDeadlineSeconds):: __specMixin({progressDeadlineSeconds: progressDeadlineSeconds}),
            // Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
            replicas(replicas):: __specMixin({replicas: replicas}),
            // The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified. Defaults to 2.
            revisionHistoryLimit(revisionHistoryLimit):: __specMixin({revisionHistoryLimit: revisionHistoryLimit}),
            // The config this deployment is rolling back to. Will be cleared after rollback is done.
            rollbackTo:: {
              local __rollbackToMixin(rollbackTo) = __specMixin({rollbackTo+: rollbackTo}),
              // The revision to rollback to. If set to 0, rollbck to the last revision.
              revision(revision):: __rollbackToMixin({revision: revision}),
            },
            // Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // The deployment strategy to use to replace existing pods with new ones.
            strategy:: {
              local __strategyMixin(strategy) = __specMixin({strategy+: strategy}),
              // Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
              rollingUpdate:: {
                local __rollingUpdateMixin(rollingUpdate) = __strategyMixin({rollingUpdate+: rollingUpdate}),
                // The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. Defaults to 25%. Example: when this is set to 30%, the new RC can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of desired pods.
                maxSurge:: {
                  local __maxSurgeMixin(maxSurge) = __rollingUpdateMixin({maxSurge+: maxSurge}),
                },
                // The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. Defaults to 25%. Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old RC can be scaled down further, followed by scaling up the new RC, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
                maxUnavailable:: {
                  local __maxUnavailableMixin(maxUnavailable) = __rollingUpdateMixin({maxUnavailable+: maxUnavailable}),
                },
              },
              // Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
              type(type):: __strategyMixin({type: type}),
            },
            // Template describes the pods that will be created.
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
          },
        },
      },
      // DeploymentList is a list of Deployments.
      deploymentList:: {
        local kind = {kind: "DeploymentList"},
        default():: apiVersion + kind,
        // Items is the list of Deployments.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // DeploymentRollback stores the information required to rollback a deployment.
      deploymentRollback:: {
        local kind = {kind: "DeploymentRollback"},
        default():: apiVersion + kind,
        // Required: This must match the Name of a deployment.
        name(name):: {name: name},
        // The annotations to be updated to a deployment
        updatedAnnotations(updatedAnnotations):: {updatedAnnotations+: updatedAnnotations},
        mixin:: {
          // The config of this deployment rollback.
          rollbackTo:: {
            local __rollbackToMixin(rollbackTo) = {rollbackTo+: rollbackTo},
            // The revision to rollback to. If set to 0, rollbck to the last revision.
            revision(revision):: __rollbackToMixin({revision: revision}),
          },
        },
      },
      // Scale represents a scaling request for a resource.
      scale:: {
        local kind = {kind: "Scale"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object metadata; More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // defines the behavior of the scale. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // desired number of instances for the scaled object.
            replicas(replicas):: __specMixin({replicas: replicas}),
          },
        },
      },
      // StatefulSet represents a set of pods with consistent identities. Identities are defined as:
      //  - Network: A single stable DNS and hostname.
      //  - Storage: As many VolumeClaims as requested.
      // The StatefulSet guarantees that a given network identity will always map to the same storage identity.
      statefulSet:: {
        local kind = {kind: "StatefulSet"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the desired identities of pods in this set.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Replicas is the desired number of replicas of the given Template. These are replicas in the sense that they are instantiations of the same Template, but individual replicas also have a consistent identity. If unspecified, defaults to 1.
            replicas(replicas):: __specMixin({replicas: replicas}),
            // Selector is a label query over pods that should match the replica count. If empty, defaulted to labels on the pod template. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // ServiceName is the name of the service that governs this StatefulSet. This service must exist before the StatefulSet, and is responsible for the network identity of the set. Pods get DNS/hostnames that follow the pattern: pod-specific-string.serviceName.default.svc.cluster.local where "pod-specific-string" is managed by the StatefulSet controller.
            serviceName(serviceName):: __specMixin({serviceName: serviceName}),
            // Template is the object that describes the pod that will be created if insufficient replicas are detected. Each pod stamped out by the StatefulSet will fulfill this Template, but have a unique identity from the rest of the StatefulSet.
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
            // VolumeClaimTemplates is a list of claims that pods are allowed to reference. The StatefulSet controller is responsible for mapping network identities to claims in a way that maintains the identity of a pod. Every claim in this list must have at least one matching (by name) volumeMount in one container in the template. A claim in this list takes precedence over any volumes in the template, with the same name.
            volumeClaimTemplates(volumeClaimTemplates):: if std.type(volumeClaimTemplates) == "array" then __specMixin({volumeClaimTemplates+: volumeClaimTemplates}) else __specMixin({volumeClaimTemplates: [volumeClaimTemplates]}),
          },
        },
      },
      // StatefulSetList is a collection of StatefulSets.
      statefulSetList:: {
        local kind = {kind: "StatefulSetList"},
        default():: apiVersion + kind,
        //
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  authentication:: {
    v1:: {
      local apiVersion = {apiVersion: "authentication/v1"},
      // TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
      tokenReview:: {
        local kind = {kind: "TokenReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Token is the opaque bearer token.
            token(token):: __specMixin({token: token}),
          },
        },
      },
    },
    v1beta1:: {
      local apiVersion = {apiVersion: "authentication/v1beta1"},
      // TokenReview attempts to authenticate a token to a known user. Note: TokenReview requests may be cached by the webhook token authenticator plugin in the kube-apiserver.
      tokenReview:: {
        local kind = {kind: "TokenReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Token is the opaque bearer token.
            token(token):: __specMixin({token: token}),
          },
        },
      },
    },
  },
  authorization:: {
    v1:: {
      local apiVersion = {apiVersion: "authorization/v1"},
      // LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
      localSubjectAccessReview:: {
        local kind = {kind: "LocalSubjectAccessReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated.  spec.namespace must be equal to the namespace you made the request against.  If empty, it is defaulted.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here.
            extra(extra):: __specMixin({extra+: extra}),
            // Groups is the groups you're testing for.
            groups(groups):: if std.type(groups) == "array" then __specMixin({groups+: groups}) else __specMixin({groups: [groups]}),
            // NonResourceAttributes describes information for a non-resource access request
            nonResourceAttributes:: {
              local __nonResourceAttributesMixin(nonResourceAttributes) = __specMixin({nonResourceAttributes+: nonResourceAttributes}),
              // Path is the URL path of the request
              path(path):: __nonResourceAttributesMixin({path: path}),
              // Verb is the standard HTTP verb
              verb(verb):: __nonResourceAttributesMixin({verb: verb}),
            },
            // ResourceAuthorizationAttributes describes information for a resource access request
            resourceAttributes:: {
              local __resourceAttributesMixin(resourceAttributes) = __specMixin({resourceAttributes+: resourceAttributes}),
              // Group is the API Group of the Resource.  "*" means all.
              group(group):: __resourceAttributesMixin({group: group}),
              // Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all.
              name(name):: __resourceAttributesMixin({name: name}),
              // Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
              namespace(namespace):: __resourceAttributesMixin({namespace: namespace}),
              // Resource is one of the existing resource types.  "*" means all.
              resource(resource):: __resourceAttributesMixin({resource: resource}),
              // Subresource is one of the existing resource types.  "" means none.
              subresource(subresource):: __resourceAttributesMixin({subresource: subresource}),
              // Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
              verb(verb):: __resourceAttributesMixin({verb: verb}),
              // Version is the API Version of the Resource.  "*" means all.
              version(version):: __resourceAttributesMixin({version: version}),
            },
            // User is the user you're testing for. If you specify "User" but not "Groups", then is it interpreted as "What if User were not a member of any groups
            user(user):: __specMixin({user: user}),
          },
        },
      },
      // SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means "in all namespaces".  Self is a special case, because users should always be able to check whether they can perform an action
      selfSubjectAccessReview:: {
        local kind = {kind: "SelfSubjectAccessReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated.  user and groups must be empty
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // NonResourceAttributes describes information for a non-resource access request
            nonResourceAttributes:: {
              local __nonResourceAttributesMixin(nonResourceAttributes) = __specMixin({nonResourceAttributes+: nonResourceAttributes}),
              // Path is the URL path of the request
              path(path):: __nonResourceAttributesMixin({path: path}),
              // Verb is the standard HTTP verb
              verb(verb):: __nonResourceAttributesMixin({verb: verb}),
            },
            // ResourceAuthorizationAttributes describes information for a resource access request
            resourceAttributes:: {
              local __resourceAttributesMixin(resourceAttributes) = __specMixin({resourceAttributes+: resourceAttributes}),
              // Group is the API Group of the Resource.  "*" means all.
              group(group):: __resourceAttributesMixin({group: group}),
              // Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all.
              name(name):: __resourceAttributesMixin({name: name}),
              // Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
              namespace(namespace):: __resourceAttributesMixin({namespace: namespace}),
              // Resource is one of the existing resource types.  "*" means all.
              resource(resource):: __resourceAttributesMixin({resource: resource}),
              // Subresource is one of the existing resource types.  "" means none.
              subresource(subresource):: __resourceAttributesMixin({subresource: subresource}),
              // Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
              verb(verb):: __resourceAttributesMixin({verb: verb}),
              // Version is the API Version of the Resource.  "*" means all.
              version(version):: __resourceAttributesMixin({version: version}),
            },
          },
        },
      },
      // SubjectAccessReview checks whether or not a user or group can perform an action.
      subjectAccessReview:: {
        local kind = {kind: "SubjectAccessReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here.
            extra(extra):: __specMixin({extra+: extra}),
            // Groups is the groups you're testing for.
            groups(groups):: if std.type(groups) == "array" then __specMixin({groups+: groups}) else __specMixin({groups: [groups]}),
            // NonResourceAttributes describes information for a non-resource access request
            nonResourceAttributes:: {
              local __nonResourceAttributesMixin(nonResourceAttributes) = __specMixin({nonResourceAttributes+: nonResourceAttributes}),
              // Path is the URL path of the request
              path(path):: __nonResourceAttributesMixin({path: path}),
              // Verb is the standard HTTP verb
              verb(verb):: __nonResourceAttributesMixin({verb: verb}),
            },
            // ResourceAuthorizationAttributes describes information for a resource access request
            resourceAttributes:: {
              local __resourceAttributesMixin(resourceAttributes) = __specMixin({resourceAttributes+: resourceAttributes}),
              // Group is the API Group of the Resource.  "*" means all.
              group(group):: __resourceAttributesMixin({group: group}),
              // Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all.
              name(name):: __resourceAttributesMixin({name: name}),
              // Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
              namespace(namespace):: __resourceAttributesMixin({namespace: namespace}),
              // Resource is one of the existing resource types.  "*" means all.
              resource(resource):: __resourceAttributesMixin({resource: resource}),
              // Subresource is one of the existing resource types.  "" means none.
              subresource(subresource):: __resourceAttributesMixin({subresource: subresource}),
              // Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
              verb(verb):: __resourceAttributesMixin({verb: verb}),
              // Version is the API Version of the Resource.  "*" means all.
              version(version):: __resourceAttributesMixin({version: version}),
            },
            // User is the user you're testing for. If you specify "User" but not "Groups", then is it interpreted as "What if User were not a member of any groups
            user(user):: __specMixin({user: user}),
          },
        },
      },
    },
    v1beta1:: {
      local apiVersion = {apiVersion: "authorization/v1beta1"},
      // LocalSubjectAccessReview checks whether or not a user or group can perform an action in a given namespace. Having a namespace scoped resource makes it much easier to grant namespace scoped policy that includes permissions checking.
      localSubjectAccessReview:: {
        local kind = {kind: "LocalSubjectAccessReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated.  spec.namespace must be equal to the namespace you made the request against.  If empty, it is defaulted.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here.
            extra(extra):: __specMixin({extra+: extra}),
            // Groups is the groups you're testing for.
            group(group):: if std.type(group) == "array" then __specMixin({group+: group}) else __specMixin({group: [group]}),
            // NonResourceAttributes describes information for a non-resource access request
            nonResourceAttributes:: {
              local __nonResourceAttributesMixin(nonResourceAttributes) = __specMixin({nonResourceAttributes+: nonResourceAttributes}),
              // Path is the URL path of the request
              path(path):: __nonResourceAttributesMixin({path: path}),
              // Verb is the standard HTTP verb
              verb(verb):: __nonResourceAttributesMixin({verb: verb}),
            },
            // ResourceAuthorizationAttributes describes information for a resource access request
            resourceAttributes:: {
              local __resourceAttributesMixin(resourceAttributes) = __specMixin({resourceAttributes+: resourceAttributes}),
              // Group is the API Group of the Resource.  "*" means all.
              group(group):: __resourceAttributesMixin({group: group}),
              // Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all.
              name(name):: __resourceAttributesMixin({name: name}),
              // Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
              namespace(namespace):: __resourceAttributesMixin({namespace: namespace}),
              // Resource is one of the existing resource types.  "*" means all.
              resource(resource):: __resourceAttributesMixin({resource: resource}),
              // Subresource is one of the existing resource types.  "" means none.
              subresource(subresource):: __resourceAttributesMixin({subresource: subresource}),
              // Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
              verb(verb):: __resourceAttributesMixin({verb: verb}),
              // Version is the API Version of the Resource.  "*" means all.
              version(version):: __resourceAttributesMixin({version: version}),
            },
            // User is the user you're testing for. If you specify "User" but not "Group", then is it interpreted as "What if User were not a member of any groups
            user(user):: __specMixin({user: user}),
          },
        },
      },
      // SelfSubjectAccessReview checks whether or the current user can perform an action.  Not filling in a spec.namespace means "in all namespaces".  Self is a special case, because users should always be able to check whether they can perform an action
      selfSubjectAccessReview:: {
        local kind = {kind: "SelfSubjectAccessReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated.  user and groups must be empty
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // NonResourceAttributes describes information for a non-resource access request
            nonResourceAttributes:: {
              local __nonResourceAttributesMixin(nonResourceAttributes) = __specMixin({nonResourceAttributes+: nonResourceAttributes}),
              // Path is the URL path of the request
              path(path):: __nonResourceAttributesMixin({path: path}),
              // Verb is the standard HTTP verb
              verb(verb):: __nonResourceAttributesMixin({verb: verb}),
            },
            // ResourceAuthorizationAttributes describes information for a resource access request
            resourceAttributes:: {
              local __resourceAttributesMixin(resourceAttributes) = __specMixin({resourceAttributes+: resourceAttributes}),
              // Group is the API Group of the Resource.  "*" means all.
              group(group):: __resourceAttributesMixin({group: group}),
              // Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all.
              name(name):: __resourceAttributesMixin({name: name}),
              // Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
              namespace(namespace):: __resourceAttributesMixin({namespace: namespace}),
              // Resource is one of the existing resource types.  "*" means all.
              resource(resource):: __resourceAttributesMixin({resource: resource}),
              // Subresource is one of the existing resource types.  "" means none.
              subresource(subresource):: __resourceAttributesMixin({subresource: subresource}),
              // Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
              verb(verb):: __resourceAttributesMixin({verb: verb}),
              // Version is the API Version of the Resource.  "*" means all.
              version(version):: __resourceAttributesMixin({version: version}),
            },
          },
        },
      },
      // SubjectAccessReview checks whether or not a user or group can perform an action.
      subjectAccessReview:: {
        local kind = {kind: "SubjectAccessReview"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec holds information about the request being evaluated
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Extra corresponds to the user.Info.GetExtra() method from the authenticator.  Since that is input to the authorizer it needs a reflection here.
            extra(extra):: __specMixin({extra+: extra}),
            // Groups is the groups you're testing for.
            group(group):: if std.type(group) == "array" then __specMixin({group+: group}) else __specMixin({group: [group]}),
            // NonResourceAttributes describes information for a non-resource access request
            nonResourceAttributes:: {
              local __nonResourceAttributesMixin(nonResourceAttributes) = __specMixin({nonResourceAttributes+: nonResourceAttributes}),
              // Path is the URL path of the request
              path(path):: __nonResourceAttributesMixin({path: path}),
              // Verb is the standard HTTP verb
              verb(verb):: __nonResourceAttributesMixin({verb: verb}),
            },
            // ResourceAuthorizationAttributes describes information for a resource access request
            resourceAttributes:: {
              local __resourceAttributesMixin(resourceAttributes) = __specMixin({resourceAttributes+: resourceAttributes}),
              // Group is the API Group of the Resource.  "*" means all.
              group(group):: __resourceAttributesMixin({group: group}),
              // Name is the name of the resource being requested for a "get" or deleted for a "delete". "" (empty) means all.
              name(name):: __resourceAttributesMixin({name: name}),
              // Namespace is the namespace of the action being requested.  Currently, there is no distinction between no namespace and all namespaces "" (empty) is defaulted for LocalSubjectAccessReviews "" (empty) is empty for cluster-scoped resources "" (empty) means "all" for namespace scoped resources from a SubjectAccessReview or SelfSubjectAccessReview
              namespace(namespace):: __resourceAttributesMixin({namespace: namespace}),
              // Resource is one of the existing resource types.  "*" means all.
              resource(resource):: __resourceAttributesMixin({resource: resource}),
              // Subresource is one of the existing resource types.  "" means none.
              subresource(subresource):: __resourceAttributesMixin({subresource: subresource}),
              // Verb is a kubernetes resource API verb, like: get, list, watch, create, update, delete, proxy.  "*" means all.
              verb(verb):: __resourceAttributesMixin({verb: verb}),
              // Version is the API Version of the Resource.  "*" means all.
              version(version):: __resourceAttributesMixin({version: version}),
            },
            // User is the user you're testing for. If you specify "User" but not "Group", then is it interpreted as "What if User were not a member of any groups
            user(user):: __specMixin({user: user}),
          },
        },
      },
    },
  },
  autoscaling:: {
    v1:: {
      local apiVersion = {apiVersion: "autoscaling/v1"},
      // configuration of a horizontal pod autoscaler.
      horizontalPodAutoscaler:: {
        local kind = {kind: "HorizontalPodAutoscaler"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object metadata. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // behaviour of autoscaler. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // upper limit for the number of pods that can be set by the autoscaler; cannot be smaller than MinReplicas.
            maxReplicas(maxReplicas):: __specMixin({maxReplicas: maxReplicas}),
            // lower limit for the number of pods that can be set by the autoscaler, default 1.
            minReplicas(minReplicas):: __specMixin({minReplicas: minReplicas}),
            // reference to scaled resource; horizontal pod autoscaler will learn the current resource consumption and will set the desired number of pods by using its Scale subresource.
            scaleTargetRef:: {
              local __scaleTargetRefMixin(scaleTargetRef) = __specMixin({scaleTargetRef+: scaleTargetRef}),
              // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
              name(name):: __scaleTargetRefMixin({name: name}),
            },
            // target average CPU utilization (represented as a percentage of requested CPU) over all the pods; if not specified the default autoscaling policy will be used.
            targetCpuUtilizationPercentage(targetCpuUtilizationPercentage):: __specMixin({targetCPUUtilizationPercentage: targetCpuUtilizationPercentage}),
          },
        },
      },
      // list of horizontal pod autoscaler objects.
      horizontalPodAutoscalerList:: {
        local kind = {kind: "HorizontalPodAutoscalerList"},
        default():: apiVersion + kind,
        // list of horizontal pod autoscaler objects.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Scale represents a scaling request for a resource.
      scale:: {
        local kind = {kind: "Scale"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object metadata; More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // defines the behavior of the scale. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // desired number of instances for the scaled object.
            replicas(replicas):: __specMixin({replicas: replicas}),
          },
        },
      },
    },
    v2alpha1:: {
      local apiVersion = {apiVersion: "autoscaling/v2alpha1"},
      // HorizontalPodAutoscaler is the configuration for a horizontal pod autoscaler, which automatically manages the replica count of any resource implementing the scale subresource based on the metrics specified.
      horizontalPodAutoscaler:: {
        local kind = {kind: "HorizontalPodAutoscaler"},
        default():: apiVersion + kind,
        mixin:: {
          // metadata is the standard object metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // spec is the specification for the behaviour of the autoscaler. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // maxReplicas is the upper limit for the number of replicas to which the autoscaler can scale up. It cannot be less that minReplicas.
            maxReplicas(maxReplicas):: __specMixin({maxReplicas: maxReplicas}),
            // metrics contains the specifications for which to use to calculate the desired replica count (the maximum replica count across all metrics will be used).  The desired replica count is calculated multiplying the ratio between the target value and the current value by the current number of pods.  Ergo, metrics used must decrease as the pod count is increased, and vice-versa.  See the individual metric source types for more information about how each type of metric must respond.
            metrics(metrics):: if std.type(metrics) == "array" then __specMixin({metrics+: metrics}) else __specMixin({metrics: [metrics]}),
            // minReplicas is the lower limit for the number of replicas to which the autoscaler can scale down. It defaults to 1 pod.
            minReplicas(minReplicas):: __specMixin({minReplicas: minReplicas}),
            // scaleTargetRef points to the target resource to scale, and is used to the pods for which metrics should be collected, as well as to actually change the replica count.
            scaleTargetRef:: {
              local __scaleTargetRefMixin(scaleTargetRef) = __specMixin({scaleTargetRef+: scaleTargetRef}),
              // Name of the referent; More info: http://kubernetes.io/docs/user-guide/identifiers#names
              name(name):: __scaleTargetRefMixin({name: name}),
            },
          },
        },
      },
      // HorizontalPodAutoscaler is a list of horizontal pod autoscaler objects.
      horizontalPodAutoscalerList:: {
        local kind = {kind: "HorizontalPodAutoscalerList"},
        default():: apiVersion + kind,
        // items is the list of horizontal pod autoscaler objects.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  batch:: {
    v1:: {
      local apiVersion = {apiVersion: "batch/v1"},
      // Job represents the configuration of a single job.
      job:: {
        local kind = {kind: "Job"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior of a job. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Optional duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer
            activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
            // Specifies the desired number of successfully finished pods the job should be run with.  Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value.  Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
            completions(completions):: __specMixin({completions: completions}),
            // manualSelector controls generation of pod labels and pod selectors. Leave `manualSelector` unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template.  When true, the user is responsible for picking unique labels and specifying the selector.  Failure to pick a unique label may cause this and other jobs to not function correctly.  However, You may see `manualSelector=true` in jobs that were created with the old `extensions/v1beta1` API. More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/selector-generation.md
            manualSelector(manualSelector):: __specMixin({manualSelector: manualSelector}),
            // Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
            parallelism(parallelism):: __specMixin({parallelism: parallelism}),
            // A label query over pods that should match the pod count. Normally, the system sets this field for you. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
          },
        },
      },
      // JobList is a collection of jobs.
      jobList:: {
        local kind = {kind: "JobList"},
        default():: apiVersion + kind,
        // items is the list of Jobs.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
    v2alpha1:: {
      local apiVersion = {apiVersion: "batch/v2alpha1"},
      // CronJob represents the configuration of a single cron job.
      cronJob:: {
        local kind = {kind: "CronJob"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior of a cron job, including the schedule. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Specifies how to treat concurrent executions of a Job. Defaults to Allow.
            concurrencyPolicy(concurrencyPolicy):: __specMixin({concurrencyPolicy: concurrencyPolicy}),
            // The number of failed finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified.
            failedJobsHistoryLimit(failedJobsHistoryLimit):: __specMixin({failedJobsHistoryLimit: failedJobsHistoryLimit}),
            // Specifies the job that will be created when executing a CronJob.
            jobTemplate:: {
              local __jobTemplateMixin(jobTemplate) = __specMixin({jobTemplate+: jobTemplate}),
              // Specification of the desired behavior of the job. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __jobTemplateMixin({spec+: spec}),
                // Optional duration in seconds relative to the startTime that the job may be active before the system tries to terminate it; value must be positive integer
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // Specifies the desired number of successfully finished pods the job should be run with.  Setting to nil means that the success of any pod signals the success of all pods, and allows parallelism to have any positive value.  Setting to 1 means that parallelism is limited to 1 and the success of that pod signals the success of the job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
                completions(completions):: __specMixin({completions: completions}),
                // manualSelector controls generation of pod labels and pod selectors. Leave `manualSelector` unset unless you are certain what you are doing. When false or unset, the system pick labels unique to this job and appends those labels to the pod template.  When true, the user is responsible for picking unique labels and specifying the selector.  Failure to pick a unique label may cause this and other jobs to not function correctly.  However, You may see `manualSelector=true` in jobs that were created with the old `extensions/v1beta1` API. More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/selector-generation.md
                manualSelector(manualSelector):: __specMixin({manualSelector: manualSelector}),
                // Specifies the maximum desired number of pods the job should run at any given time. The actual number of pods running in steady state will be less than this number when ((.spec.completions - .status.successful) < .spec.parallelism), i.e. when the work left to do is less than max parallelism. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
                parallelism(parallelism):: __specMixin({parallelism: parallelism}),
                // A label query over pods that should match the pod count. Normally, the system sets this field for you. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
                selector:: {
                  local __selectorMixin(selector) = __specMixin({selector+: selector}),
                  // matchExpressions is a list of label selector requirements. The requirements are ANDed.
                  matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
                  // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
                  matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
                },
                // Describes the pod that will be created when executing a job. More info: https://kubernetes.io/docs/concepts/workloads/controllers/jobs-run-to-completion/
                template:: {
                  local __templateMixin(template) = __specMixin({template+: template}),
                  // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
                  spec:: {
                    local __specMixin(spec) = __templateMixin({spec+: spec}),
                    // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                    activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                    // If specified, the pod's scheduling constraints
                    affinity:: {
                      local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                      // Describes node affinity scheduling rules for the pod.
                      nodeAffinity:: {
                        local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                        // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                        preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                        // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                        requiredDuringSchedulingIgnoredDuringExecution:: {
                          local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                          // Required. A list of node selector terms. The terms are ORed.
                          nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                        },
                      },
                      // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                      podAffinity:: {
                        local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                        // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                        preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                        // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                        requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                      },
                      // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                      podAntiAffinity:: {
                        local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                        // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                        preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                        // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                        requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                      },
                    },
                    // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                    automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                    // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                    containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                    // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                    dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                    // Use the host's ipc namespace. Optional: Default to false.
                    hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                    // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                    hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                    // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                    hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                    // Use the host's pid namespace. Optional: Default to false.
                    hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                    // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                    hostname(hostname):: __specMixin({hostname: hostname}),
                    // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                    imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                    // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                    initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                    // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                    nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                    // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                    nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                    // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                    restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                    // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                    schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                    // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                    securityContext:: {
                      local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                      // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                      //
                      // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                      //
                      // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                      fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                      // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                      runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                      // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                      runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                      // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                      seLinuxOptions:: {
                        local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                        // Level is SELinux level label that applies to the container.
                        level(level):: __seLinuxOptionsMixin({level: level}),
                        // Role is a SELinux role label that applies to the container.
                        role(role):: __seLinuxOptionsMixin({role: role}),
                        // Type is a SELinux type label that applies to the container.
                        type(type):: __seLinuxOptionsMixin({type: type}),
                        // User is a SELinux user label that applies to the container.
                        user(user):: __seLinuxOptionsMixin({user: user}),
                      },
                      // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                      supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                    },
                    // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                    serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                    // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                    serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                    // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                    subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                    // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                    terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                    // If specified, the pod's tolerations.
                    tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                    // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                    volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
                  },
                },
              },
            },
            // The schedule in Cron format, see https://en.wikipedia.org/wiki/Cron.
            schedule(schedule):: __specMixin({schedule: schedule}),
            // Optional deadline in seconds for starting the job if it misses scheduled time for any reason.  Missed jobs executions will be counted as failed ones.
            startingDeadlineSeconds(startingDeadlineSeconds):: __specMixin({startingDeadlineSeconds: startingDeadlineSeconds}),
            // The number of successful finished jobs to retain. This is a pointer to distinguish between explicit zero and not specified.
            successfulJobsHistoryLimit(successfulJobsHistoryLimit):: __specMixin({successfulJobsHistoryLimit: successfulJobsHistoryLimit}),
            // This flag tells the controller to suspend subsequent executions, it does not apply to already started executions.  Defaults to false.
            suspend(suspend):: __specMixin({suspend: suspend}),
          },
        },
      },
      // CronJobList is a collection of cron jobs.
      cronJobList:: {
        local kind = {kind: "CronJobList"},
        default():: apiVersion + kind,
        // items is the list of CronJobs.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  certificates:: {
    v1beta1:: {
      local apiVersion = {apiVersion: "certificates/v1beta1"},
      // Describes a certificate signing request
      certificateSigningRequest:: {
        local kind = {kind: "CertificateSigningRequest"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // The certificate request itself and any additional information.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Extra information about the requesting user. See user.Info interface for details.
            extra(extra):: __specMixin({extra+: extra}),
            // Group information about the requesting user. See user.Info interface for details.
            groups(groups):: if std.type(groups) == "array" then __specMixin({groups+: groups}) else __specMixin({groups: [groups]}),
            // Base64-encoded PKCS#10 CSR data
            request(request):: __specMixin({request: request}),
            // UID information about the requesting user. See user.Info interface for details.
            uid(uid):: __specMixin({uid: uid}),
            // allowedUsages specifies a set of usage contexts the key will be valid for. See: https://tools.ietf.org/html/rfc5280#section-4.2.1.3
            //      https://tools.ietf.org/html/rfc5280#section-4.2.1.12
            usages(usages):: if std.type(usages) == "array" then __specMixin({usages+: usages}) else __specMixin({usages: [usages]}),
            // Information about the requesting user. See user.Info interface for details.
            username(username):: __specMixin({username: username}),
          },
        },
      },
      //
      certificateSigningRequestList:: {
        local kind = {kind: "CertificateSigningRequestList"},
        default():: apiVersion + kind,
        //
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  core:: {
    intstr:: {
      local apiVersion = {apiVersion: "intstr"},
    },
    resource:: {
      local apiVersion = {apiVersion: "resource"},
    },
    v1:: {
      local apiVersion = {apiVersion: "v1"},
      // Binding ties one object to another. For example, a pod is bound to a node by a scheduler.
      binding:: {
        local kind = {kind: "Binding"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // The target object that you want to bind to the standard object.
          target:: {
            local __targetMixin(target) = {target+: target},
            // If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
            fieldPath(fieldPath):: __targetMixin({fieldPath: fieldPath}),
            // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            name(name):: __targetMixin({name: name}),
            // Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            namespace(namespace):: __targetMixin({namespace: namespace}),
            // Specific resourceVersion to which this reference is made, if any. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency
            resourceVersion(resourceVersion):: __targetMixin({resourceVersion: resourceVersion}),
            // UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            uid(uid):: __targetMixin({uid: uid}),
          },
        },
      },
      // ComponentStatus (and ComponentStatusList) holds the cluster validation info.
      componentStatus:: {
        local kind = {kind: "ComponentStatus"},
        default():: apiVersion + kind,
        // List of component conditions observed
        conditions(conditions):: if std.type(conditions) == "array" then {conditions+: conditions} else {conditions: [conditions]},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // Status of all the conditions for the component as a list of ComponentStatus objects.
      componentStatusList:: {
        local kind = {kind: "ComponentStatusList"},
        default():: apiVersion + kind,
        // List of ComponentStatus objects.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ConfigMap holds configuration data for pods to consume.
      configMap:: {
        local kind = {kind: "ConfigMap"},
        default():: apiVersion + kind,
        // Data contains the configuration data. Each key must consist of alphanumeric characters, '-', '_' or '.'.
        data(data):: {data+: data},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // ConfigMapList is a resource containing a list of ConfigMap objects.
      configMapList:: {
        local kind = {kind: "ConfigMapList"},
        default():: apiVersion + kind,
        // Items is the list of ConfigMaps.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Endpoints is a collection of endpoints that implement the actual service. Example:
      //   Name: "mysvc",
      //   Subsets: [
      //     {
      //       Addresses: [{"ip": "10.10.1.1"}, {"ip": "10.10.2.2"}],
      //       Ports: [{"name": "a", "port": 8675}, {"name": "b", "port": 309}]
      //     },
      //     {
      //       Addresses: [{"ip": "10.10.3.3"}],
      //       Ports: [{"name": "a", "port": 93}, {"name": "b", "port": 76}]
      //     },
      //  ]
      endpoints:: {
        local kind = {kind: "Endpoints"},
        default():: apiVersion + kind,
        // The set of all endpoints is the union of all subsets. Addresses are placed into subsets according to the IPs they share. A single address with multiple ports, some of which are ready and some of which are not (because they come from different containers) will result in the address being displayed in different subsets for the different ports. No address will appear in both Addresses and NotReadyAddresses in the same subset. Sets of addresses and ports that comprise a service.
        subsets(subsets):: if std.type(subsets) == "array" then {subsets+: subsets} else {subsets: [subsets]},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // EndpointsList is a list of endpoints.
      endpointsList:: {
        local kind = {kind: "EndpointsList"},
        default():: apiVersion + kind,
        // List of endpoints.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Event is a report of an event somewhere in the cluster.
      event:: {
        local kind = {kind: "Event"},
        default():: apiVersion + kind,
        // The number of times this event has occurred.
        count(count):: {count: count},
        // A human-readable description of the status of this operation.
        message(message):: {message: message},
        // This should be a short, machine understandable string that gives the reason for the transition into the object's current status.
        reason(reason):: {reason: reason},
        // Type of this event (Normal, Warning), new types could be added in the future
        type(type):: {type: type},
        mixin:: {
          // The time at which the event was first recorded. (Time of server receipt is in TypeMeta.)
          firstTimestamp:: {
            local __firstTimestampMixin(firstTimestamp) = {firstTimestamp+: firstTimestamp},
          },
          // The object that this event is about.
          involvedObject:: {
            local __involvedObjectMixin(involvedObject) = {involvedObject+: involvedObject},
            // If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
            fieldPath(fieldPath):: __involvedObjectMixin({fieldPath: fieldPath}),
            // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
            name(name):: __involvedObjectMixin({name: name}),
            // Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
            namespace(namespace):: __involvedObjectMixin({namespace: namespace}),
            // Specific resourceVersion to which this reference is made, if any. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency
            resourceVersion(resourceVersion):: __involvedObjectMixin({resourceVersion: resourceVersion}),
            // UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
            uid(uid):: __involvedObjectMixin({uid: uid}),
          },
          // The time at which the most recent occurrence of this event was recorded.
          lastTimestamp:: {
            local __lastTimestampMixin(lastTimestamp) = {lastTimestamp+: lastTimestamp},
          },
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // The component reporting this event. Should be a short machine understandable string.
          source:: {
            local __sourceMixin(source) = {source+: source},
            // Component from which the event is generated.
            component(component):: __sourceMixin({component: component}),
            // Node name on which the event is generated.
            host(host):: __sourceMixin({host: host}),
          },
        },
      },
      // EventList is a list of events.
      eventList:: {
        local kind = {kind: "EventList"},
        default():: apiVersion + kind,
        // List of events
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // LimitRange sets resource usage limits for each kind of resource in a Namespace.
      limitRange:: {
        local kind = {kind: "LimitRange"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the limits enforced. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Limits is the list of LimitRangeItem objects that are enforced.
            limits(limits):: if std.type(limits) == "array" then __specMixin({limits+: limits}) else __specMixin({limits: [limits]}),
          },
        },
      },
      // LimitRangeList is a list of LimitRange items.
      limitRangeList:: {
        local kind = {kind: "LimitRangeList"},
        default():: apiVersion + kind,
        // Items is a list of LimitRange objects. More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/admission_control_limit_range.md
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Namespace provides a scope for Names. Use of multiple namespaces is optional.
      namespace:: {
        local kind = {kind: "Namespace"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the behavior of the Namespace. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Finalizers is an opaque list of values that must be empty to permanently remove object from storage. More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/namespaces.md#finalizers
            finalizers(finalizers):: if std.type(finalizers) == "array" then __specMixin({finalizers+: finalizers}) else __specMixin({finalizers: [finalizers]}),
          },
        },
      },
      // NamespaceList is a list of Namespaces.
      namespaceList:: {
        local kind = {kind: "NamespaceList"},
        default():: apiVersion + kind,
        // Items is the list of Namespace objects in the list. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Node is a worker node in Kubernetes. Each node will have a unique identifier in the cache (i.e. in etcd).
      node:: {
        local kind = {kind: "Node"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the behavior of a node. https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // External ID of the node assigned by some machine database (e.g. a cloud provider). Deprecated.
            externalId(externalId):: __specMixin({externalID: externalId}),
            // PodCIDR represents the pod IP range assigned to the node.
            podCidr(podCidr):: __specMixin({podCIDR: podCidr}),
            // ID of the node assigned by the cloud provider in the format: <ProviderName>://<ProviderSpecificNodeID>
            providerId(providerId):: __specMixin({providerID: providerId}),
            // If specified, the node's taints.
            taints(taints):: if std.type(taints) == "array" then __specMixin({taints+: taints}) else __specMixin({taints: [taints]}),
            // Unschedulable controls node schedulability of new pods. By default, node is schedulable. More info: https://kubernetes.io/docs/concepts/nodes/node/#manual-node-administration
            unschedulable(unschedulable):: __specMixin({unschedulable: unschedulable}),
          },
        },
      },
      // NodeList is the whole list of all Nodes which have been registered with master.
      nodeList:: {
        local kind = {kind: "NodeList"},
        default():: apiVersion + kind,
        // List of nodes
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // PersistentVolume (PV) is a storage resource provisioned by an administrator. It is analogous to a node. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
      persistentVolume:: {
        local kind = {kind: "PersistentVolume"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines a specification of a persistent volume owned by the cluster. Provisioned by an administrator. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistent-volumes
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // AccessModes contains all ways the volume can be mounted. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes
            accessModes(accessModes):: if std.type(accessModes) == "array" then __specMixin({accessModes+: accessModes}) else __specMixin({accessModes: [accessModes]}),
            // AWSElasticBlockStore represents an AWS Disk resource that is attached to a kubelet's host machine and then exposed to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
            awsElasticBlockStore:: {
              local __awsElasticBlockStoreMixin(awsElasticBlockStore) = __specMixin({awsElasticBlockStore+: awsElasticBlockStore}),
              // Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
              fsType(fsType):: __awsElasticBlockStoreMixin({fsType: fsType}),
              // The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty).
              partition(partition):: __awsElasticBlockStoreMixin({partition: partition}),
              // Specify "true" to force and set the ReadOnly property in VolumeMounts to "true". If omitted, the default is "false". More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
              readOnly(readOnly):: __awsElasticBlockStoreMixin({readOnly: readOnly}),
              // Unique ID of the persistent disk resource in AWS (Amazon EBS volume). More info: https://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore
              volumeId(volumeId):: __awsElasticBlockStoreMixin({volumeID: volumeId}),
            },
            // AzureDisk represents an Azure Data Disk mount on the host and bind mount to the pod.
            azureDisk:: {
              local __azureDiskMixin(azureDisk) = __specMixin({azureDisk+: azureDisk}),
              // Host Caching mode: None, Read Only, Read Write.
              cachingMode(cachingMode):: __azureDiskMixin({cachingMode: cachingMode}),
              // The Name of the data disk in the blob storage
              diskName(diskName):: __azureDiskMixin({diskName: diskName}),
              // The URI the data disk in the blob storage
              diskUri(diskUri):: __azureDiskMixin({diskURI: diskUri}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
              fsType(fsType):: __azureDiskMixin({fsType: fsType}),
              // Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
              readOnly(readOnly):: __azureDiskMixin({readOnly: readOnly}),
            },
            // AzureFile represents an Azure File Service mount on the host and bind mount to the pod.
            azureFile:: {
              local __azureFileMixin(azureFile) = __specMixin({azureFile+: azureFile}),
              // Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
              readOnly(readOnly):: __azureFileMixin({readOnly: readOnly}),
              // the name of secret that contains Azure Storage Account Name and Key
              secretName(secretName):: __azureFileMixin({secretName: secretName}),
              // Share Name
              shareName(shareName):: __azureFileMixin({shareName: shareName}),
            },
            // A description of the persistent volume's resources and capacity. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#capacity
            capacity(capacity):: __specMixin({capacity+: capacity}),
            // CephFS represents a Ceph FS mount on the host that shares a pod's lifetime
            cephfs:: {
              local __cephfsMixin(cephfs) = __specMixin({cephfs+: cephfs}),
              // Required: Monitors is a collection of Ceph monitors More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
              monitors(monitors):: if std.type(monitors) == "array" then __cephfsMixin({monitors+: monitors}) else __cephfsMixin({monitors: [monitors]}),
              // Optional: Used as the mounted root, rather than the full Ceph tree, default is /
              path(path):: __cephfsMixin({path: path}),
              // Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
              readOnly(readOnly):: __cephfsMixin({readOnly: readOnly}),
              // Optional: SecretFile is the path to key ring for User, default is /etc/ceph/user.secret More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
              secretFile(secretFile):: __cephfsMixin({secretFile: secretFile}),
              // Optional: SecretRef is reference to the authentication secret for User, default is empty. More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
              secretRef:: {
                local __secretRefMixin(secretRef) = __cephfsMixin({secretRef+: secretRef}),
                // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                name(name):: __secretRefMixin({name: name}),
              },
              // Optional: User is the rados user name, default is admin More info: https://releases.k8s.io/HEAD/examples/volumes/cephfs/README.md#how-to-use-it
              user(user):: __cephfsMixin({user: user}),
            },
            // Cinder represents a cinder volume attached and mounted on kubelets host machine More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
            cinder:: {
              local __cinderMixin(cinder) = __specMixin({cinder+: cinder}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
              fsType(fsType):: __cinderMixin({fsType: fsType}),
              // Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts. More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
              readOnly(readOnly):: __cinderMixin({readOnly: readOnly}),
              // volume id used to identify the volume in cinder More info: https://releases.k8s.io/HEAD/examples/mysql-cinder-pd/README.md
              volumeId(volumeId):: __cinderMixin({volumeID: volumeId}),
            },
            // ClaimRef is part of a bi-directional binding between PersistentVolume and PersistentVolumeClaim. Expected to be non-nil when bound. claim.VolumeName is the authoritative bind between PV and PVC. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#binding
            claimRef:: {
              local __claimRefMixin(claimRef) = __specMixin({claimRef+: claimRef}),
              // If referring to a piece of an object instead of an entire object, this string should contain a valid JSON/Go field access statement, such as desiredState.manifest.containers[2]. For example, if the object reference is to a container within a pod, this would take on a value like: "spec.containers{name}" (where "name" refers to the name of the container that triggered the event) or if no container name is specified "spec.containers[2]" (container with index 2 in this pod). This syntax is chosen only to have some well-defined way of referencing a part of an object.
              fieldPath(fieldPath):: __claimRefMixin({fieldPath: fieldPath}),
              // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
              name(name):: __claimRefMixin({name: name}),
              // Namespace of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/namespaces/
              namespace(namespace):: __claimRefMixin({namespace: namespace}),
              // Specific resourceVersion to which this reference is made, if any. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#concurrency-control-and-consistency
              resourceVersion(resourceVersion):: __claimRefMixin({resourceVersion: resourceVersion}),
              // UID of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#uids
              uid(uid):: __claimRefMixin({uid: uid}),
            },
            // FC represents a Fibre Channel resource that is attached to a kubelet's host machine and then exposed to the pod.
            fc:: {
              local __fcMixin(fc) = __specMixin({fc+: fc}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
              fsType(fsType):: __fcMixin({fsType: fsType}),
              // Required: FC target lun number
              lun(lun):: __fcMixin({lun: lun}),
              // Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
              readOnly(readOnly):: __fcMixin({readOnly: readOnly}),
              // Required: FC target worldwide names (WWNs)
              targetWwns(targetWwns):: if std.type(targetWwns) == "array" then __fcMixin({targetWWNs+: targetWwns}) else __fcMixin({targetWWNs: [targetWwns]}),
            },
            // FlexVolume represents a generic volume resource that is provisioned/attached using an exec based plugin. This is an alpha feature and may change in future.
            flexVolume:: {
              local __flexVolumeMixin(flexVolume) = __specMixin({flexVolume+: flexVolume}),
              // Driver is the name of the driver to use for this volume.
              driver(driver):: __flexVolumeMixin({driver: driver}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". The default filesystem depends on FlexVolume script.
              fsType(fsType):: __flexVolumeMixin({fsType: fsType}),
              // Optional: Extra command options if any.
              options(options):: __flexVolumeMixin({options+: options}),
              // Optional: Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
              readOnly(readOnly):: __flexVolumeMixin({readOnly: readOnly}),
              // Optional: SecretRef is reference to the secret object containing sensitive information to pass to the plugin scripts. This may be empty if no secret object is specified. If the secret object contains more than one secret, all secrets are passed to the plugin scripts.
              secretRef:: {
                local __secretRefMixin(secretRef) = __flexVolumeMixin({secretRef+: secretRef}),
                // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                name(name):: __secretRefMixin({name: name}),
              },
            },
            // Flocker represents a Flocker volume attached to a kubelet's host machine and exposed to the pod for its usage. This depends on the Flocker control service being running
            flocker:: {
              local __flockerMixin(flocker) = __specMixin({flocker+: flocker}),
              // Name of the dataset stored as metadata -> name on the dataset for Flocker should be considered as deprecated
              datasetName(datasetName):: __flockerMixin({datasetName: datasetName}),
              // UUID of the dataset. This is unique identifier of a Flocker dataset
              datasetUuid(datasetUuid):: __flockerMixin({datasetUUID: datasetUuid}),
            },
            // GCEPersistentDisk represents a GCE Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
            gcePersistentDisk:: {
              local __gcePersistentDiskMixin(gcePersistentDisk) = __specMixin({gcePersistentDisk+: gcePersistentDisk}),
              // Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
              fsType(fsType):: __gcePersistentDiskMixin({fsType: fsType}),
              // The partition in the volume that you want to mount. If omitted, the default is to mount by volume name. Examples: For volume /dev/sda1, you specify the partition as "1". Similarly, the volume partition for /dev/sda is "0" (or you can leave the property empty). More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
              partition(partition):: __gcePersistentDiskMixin({partition: partition}),
              // Unique name of the PD resource in GCE. Used to identify the disk in GCE. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
              pdName(pdName):: __gcePersistentDiskMixin({pdName: pdName}),
              // ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk
              readOnly(readOnly):: __gcePersistentDiskMixin({readOnly: readOnly}),
            },
            // Glusterfs represents a Glusterfs volume that is attached to a host and exposed to the pod. Provisioned by an admin. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md
            glusterfs:: {
              local __glusterfsMixin(glusterfs) = __specMixin({glusterfs+: glusterfs}),
              // EndpointsName is the endpoint name that details Glusterfs topology. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
              endpoints(endpoints):: __glusterfsMixin({endpoints: endpoints}),
              // Path is the Glusterfs volume path. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
              path(path):: __glusterfsMixin({path: path}),
              // ReadOnly here will force the Glusterfs volume to be mounted with read-only permissions. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/glusterfs/README.md#create-a-pod
              readOnly(readOnly):: __glusterfsMixin({readOnly: readOnly}),
            },
            // HostPath represents a directory on the host. Provisioned by a developer or tester. This is useful for single-node development and testing only! On-host storage is not supported in any way and WILL NOT WORK in a multi-node cluster. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
            hostPath:: {
              local __hostPathMixin(hostPath) = __specMixin({hostPath+: hostPath}),
              // Path of the directory on the host. More info: https://kubernetes.io/docs/concepts/storage/volumes#hostpath
              path(path):: __hostPathMixin({path: path}),
            },
            // ISCSI represents an ISCSI Disk resource that is attached to a kubelet's host machine and then exposed to the pod. Provisioned by an admin.
            iscsi:: {
              local __iscsiMixin(iscsi) = __specMixin({iscsi+: iscsi}),
              // whether support iSCSI Discovery CHAP authentication
              chapAuthDiscovery(chapAuthDiscovery):: __iscsiMixin({chapAuthDiscovery: chapAuthDiscovery}),
              // whether support iSCSI Session CHAP authentication
              chapAuthSession(chapAuthSession):: __iscsiMixin({chapAuthSession: chapAuthSession}),
              // Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#iscsi
              fsType(fsType):: __iscsiMixin({fsType: fsType}),
              // Target iSCSI Qualified Name.
              iqn(iqn):: __iscsiMixin({iqn: iqn}),
              // Optional: Defaults to 'default' (tcp). iSCSI interface name that uses an iSCSI transport.
              iscsiInterface(iscsiInterface):: __iscsiMixin({iscsiInterface: iscsiInterface}),
              // iSCSI target lun number.
              lun(lun):: __iscsiMixin({lun: lun}),
              // iSCSI target portal List. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
              portals(portals):: if std.type(portals) == "array" then __iscsiMixin({portals+: portals}) else __iscsiMixin({portals: [portals]}),
              // ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false.
              readOnly(readOnly):: __iscsiMixin({readOnly: readOnly}),
              // CHAP secret for iSCSI target and initiator authentication
              secretRef:: {
                local __secretRefMixin(secretRef) = __iscsiMixin({secretRef+: secretRef}),
                // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                name(name):: __secretRefMixin({name: name}),
              },
              // iSCSI target portal. The portal is either an IP or ip_addr:port if the port is other than default (typically TCP ports 860 and 3260).
              targetPortal(targetPortal):: __iscsiMixin({targetPortal: targetPortal}),
            },
            // NFS represents an NFS mount on the host. Provisioned by an admin. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
            nfs:: {
              local __nfsMixin(nfs) = __specMixin({nfs+: nfs}),
              // Path that is exported by the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
              path(path):: __nfsMixin({path: path}),
              // ReadOnly here will force the NFS export to be mounted with read-only permissions. Defaults to false. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
              readOnly(readOnly):: __nfsMixin({readOnly: readOnly}),
              // Server is the hostname or IP address of the NFS server. More info: https://kubernetes.io/docs/concepts/storage/volumes#nfs
              server(server):: __nfsMixin({server: server}),
            },
            // What happens to a persistent volume when released from its claim. Valid options are Retain (default) and Recycle. Recycling must be supported by the volume plugin underlying this persistent volume. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#reclaiming
            persistentVolumeReclaimPolicy(persistentVolumeReclaimPolicy):: __specMixin({persistentVolumeReclaimPolicy: persistentVolumeReclaimPolicy}),
            // PhotonPersistentDisk represents a PhotonController persistent disk attached and mounted on kubelets host machine
            photonPersistentDisk:: {
              local __photonPersistentDiskMixin(photonPersistentDisk) = __specMixin({photonPersistentDisk+: photonPersistentDisk}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
              fsType(fsType):: __photonPersistentDiskMixin({fsType: fsType}),
              // ID that identifies Photon Controller persistent disk
              pdId(pdId):: __photonPersistentDiskMixin({pdID: pdId}),
            },
            // PortworxVolume represents a portworx volume attached and mounted on kubelets host machine
            portworxVolume:: {
              local __portworxVolumeMixin(portworxVolume) = __specMixin({portworxVolume+: portworxVolume}),
              // FSType represents the filesystem type to mount Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs". Implicitly inferred to be "ext4" if unspecified.
              fsType(fsType):: __portworxVolumeMixin({fsType: fsType}),
              // Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
              readOnly(readOnly):: __portworxVolumeMixin({readOnly: readOnly}),
              // VolumeID uniquely identifies a Portworx volume
              volumeId(volumeId):: __portworxVolumeMixin({volumeID: volumeId}),
            },
            // Quobyte represents a Quobyte mount on the host that shares a pod's lifetime
            quobyte:: {
              local __quobyteMixin(quobyte) = __specMixin({quobyte+: quobyte}),
              // Group to map volume access to Default is no group
              group(group):: __quobyteMixin({group: group}),
              // ReadOnly here will force the Quobyte volume to be mounted with read-only permissions. Defaults to false.
              readOnly(readOnly):: __quobyteMixin({readOnly: readOnly}),
              // Registry represents a single or multiple Quobyte Registry services specified as a string as host:port pair (multiple entries are separated with commas) which acts as the central registry for volumes
              registry(registry):: __quobyteMixin({registry: registry}),
              // User to map volume access to Defaults to serivceaccount user
              user(user):: __quobyteMixin({user: user}),
              // Volume is a string that references an already created Quobyte volume by name.
              volume(volume):: __quobyteMixin({volume: volume}),
            },
            // RBD represents a Rados Block Device mount on the host that shares a pod's lifetime. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md
            rbd:: {
              local __rbdMixin(rbd) = __specMixin({rbd+: rbd}),
              // Filesystem type of the volume that you want to mount. Tip: Ensure that the filesystem type is supported by the host operating system. Examples: "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified. More info: https://kubernetes.io/docs/concepts/storage/volumes#rbd
              fsType(fsType):: __rbdMixin({fsType: fsType}),
              // The rados image name. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              image(image):: __rbdMixin({image: image}),
              // Keyring is the path to key ring for RBDUser. Default is /etc/ceph/keyring. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              keyring(keyring):: __rbdMixin({keyring: keyring}),
              // A collection of Ceph monitors. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              monitors(monitors):: if std.type(monitors) == "array" then __rbdMixin({monitors+: monitors}) else __rbdMixin({monitors: [monitors]}),
              // The rados pool name. Default is rbd. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              pool(pool):: __rbdMixin({pool: pool}),
              // ReadOnly here will force the ReadOnly setting in VolumeMounts. Defaults to false. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              readOnly(readOnly):: __rbdMixin({readOnly: readOnly}),
              // SecretRef is name of the authentication secret for RBDUser. If provided overrides keyring. Default is nil. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              secretRef:: {
                local __secretRefMixin(secretRef) = __rbdMixin({secretRef+: secretRef}),
                // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                name(name):: __secretRefMixin({name: name}),
              },
              // The rados user name. Default is admin. More info: https://releases.k8s.io/HEAD/examples/volumes/rbd/README.md#how-to-use-it
              user(user):: __rbdMixin({user: user}),
            },
            // ScaleIO represents a ScaleIO persistent volume attached and mounted on Kubernetes nodes.
            scaleIo:: {
              local __scaleIoMixin(scaleIo) = __specMixin({scaleIO+: scaleIo}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
              fsType(fsType):: __scaleIoMixin({fsType: fsType}),
              // The host address of the ScaleIO API Gateway.
              gateway(gateway):: __scaleIoMixin({gateway: gateway}),
              // The name of the Protection Domain for the configured storage (defaults to "default").
              protectionDomain(protectionDomain):: __scaleIoMixin({protectionDomain: protectionDomain}),
              // Defaults to false (read/write). ReadOnly here will force the ReadOnly setting in VolumeMounts.
              readOnly(readOnly):: __scaleIoMixin({readOnly: readOnly}),
              // SecretRef references to the secret for ScaleIO user and other sensitive information. If this is not provided, Login operation will fail.
              secretRef:: {
                local __secretRefMixin(secretRef) = __scaleIoMixin({secretRef+: secretRef}),
                // Name of the referent. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/names/#names
                name(name):: __secretRefMixin({name: name}),
              },
              // Flag to enable/disable SSL communication with Gateway, default false
              sslEnabled(sslEnabled):: __scaleIoMixin({sslEnabled: sslEnabled}),
              // Indicates whether the storage for a volume should be thick or thin (defaults to "thin").
              storageMode(storageMode):: __scaleIoMixin({storageMode: storageMode}),
              // The Storage Pool associated with the protection domain (defaults to "default").
              storagePool(storagePool):: __scaleIoMixin({storagePool: storagePool}),
              // The name of the storage system as configured in ScaleIO.
              system(system):: __scaleIoMixin({system: system}),
              // The name of a volume already created in the ScaleIO system that is associated with this volume source.
              volumeName(volumeName):: __scaleIoMixin({volumeName: volumeName}),
            },
            // Name of StorageClass to which this persistent volume belongs. Empty value means that this volume does not belong to any StorageClass.
            storageClassName(storageClassName):: __specMixin({storageClassName: storageClassName}),
            // VsphereVolume represents a vSphere volume attached and mounted on kubelets host machine
            vsphereVolume:: {
              local __vsphereVolumeMixin(vsphereVolume) = __specMixin({vsphereVolume+: vsphereVolume}),
              // Filesystem type to mount. Must be a filesystem type supported by the host operating system. Ex. "ext4", "xfs", "ntfs". Implicitly inferred to be "ext4" if unspecified.
              fsType(fsType):: __vsphereVolumeMixin({fsType: fsType}),
              // Path that identifies vSphere volume vmdk
              volumePath(volumePath):: __vsphereVolumeMixin({volumePath: volumePath}),
            },
          },
        },
      },
      // PersistentVolumeClaim is a user's request for and claim to a persistent volume
      persistentVolumeClaim:: {
        local kind = {kind: "PersistentVolumeClaim"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the desired characteristics of a volume requested by a pod author. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // AccessModes contains the desired access modes the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#access-modes-1
            accessModes(accessModes):: if std.type(accessModes) == "array" then __specMixin({accessModes+: accessModes}) else __specMixin({accessModes: [accessModes]}),
            // Resources represents the minimum resources the volume should have. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#resources
            resources:: {
              local __resourcesMixin(resources) = __specMixin({resources+: resources}),
              // Limits describes the maximum amount of compute resources allowed. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
              limits(limits):: __resourcesMixin({limits+: limits}),
              // Requests describes the minimum amount of compute resources required. If Requests is omitted for a container, it defaults to Limits if that is explicitly specified, otherwise to an implementation-defined value. More info: https://kubernetes.io/docs/concepts/configuration/manage-compute-resources-container/
              requests(requests):: __resourcesMixin({requests+: requests}),
            },
            // A label query over volumes to consider for binding.
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // Name of the StorageClass required by the claim. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#class-1
            storageClassName(storageClassName):: __specMixin({storageClassName: storageClassName}),
            // VolumeName is the binding reference to the PersistentVolume backing this claim.
            volumeName(volumeName):: __specMixin({volumeName: volumeName}),
          },
        },
      },
      // PersistentVolumeClaimList is a list of PersistentVolumeClaim items.
      persistentVolumeClaimList:: {
        local kind = {kind: "PersistentVolumeClaimList"},
        default():: apiVersion + kind,
        // A list of persistent volume claims. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // PersistentVolumeList is a list of PersistentVolume items.
      persistentVolumeList:: {
        local kind = {kind: "PersistentVolumeList"},
        default():: apiVersion + kind,
        // List of persistent volumes. More info: https://kubernetes.io/docs/concepts/storage/persistent-volumes
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Pod is a collection of containers that can run on a host. This resource is created by clients and scheduled onto hosts.
      pod:: {
        local kind = {kind: "Pod"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
            activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
            // If specified, the pod's scheduling constraints
            affinity:: {
              local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
              // Describes node affinity scheduling rules for the pod.
              nodeAffinity:: {
                local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                requiredDuringSchedulingIgnoredDuringExecution:: {
                  local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                  // Required. A list of node selector terms. The terms are ORed.
                  nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                },
              },
              // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
              podAffinity:: {
                local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
              },
              // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
              podAntiAffinity:: {
                local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
              },
            },
            // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
            automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
            // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
            containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
            // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
            dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
            // Use the host's ipc namespace. Optional: Default to false.
            hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
            // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
            hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
            // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
            hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
            // Use the host's pid namespace. Optional: Default to false.
            hostPid(hostPid):: __specMixin({hostPID: hostPid}),
            // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
            hostname(hostname):: __specMixin({hostname: hostname}),
            // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
            imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
            // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
            initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
            // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
            nodeName(nodeName):: __specMixin({nodeName: nodeName}),
            // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
            nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
            // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
            restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
            // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
            schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
            // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
            securityContext:: {
              local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
              // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
              //
              // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
              //
              // If unset, the Kubelet will not modify the ownership and permissions of any volume.
              fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
              // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
              runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
              // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
              runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
              // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
              seLinuxOptions:: {
                local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                // Level is SELinux level label that applies to the container.
                level(level):: __seLinuxOptionsMixin({level: level}),
                // Role is a SELinux role label that applies to the container.
                role(role):: __seLinuxOptionsMixin({role: role}),
                // Type is a SELinux type label that applies to the container.
                type(type):: __seLinuxOptionsMixin({type: type}),
                // User is a SELinux user label that applies to the container.
                user(user):: __seLinuxOptionsMixin({user: user}),
              },
              // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
              supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
            },
            // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
            serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
            // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
            serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
            // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
            subdomain(subdomain):: __specMixin({subdomain: subdomain}),
            // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
            terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
            // If specified, the pod's tolerations.
            tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
            // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
            volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
          },
        },
      },
      // PodList is a list of Pods.
      podList:: {
        local kind = {kind: "PodList"},
        default():: apiVersion + kind,
        // List of pods. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // PodTemplate describes a template for creating copies of a predefined pod.
      podTemplate:: {
        local kind = {kind: "PodTemplate"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Template defines the pods that will be created from this pod template. https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          template:: {
            local __templateMixin(template) = {template+: template},
            // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
            spec:: {
              local __specMixin(spec) = __templateMixin({spec+: spec}),
              // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
              activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
              // If specified, the pod's scheduling constraints
              affinity:: {
                local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                // Describes node affinity scheduling rules for the pod.
                nodeAffinity:: {
                  local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                  // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                  preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                  // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                  requiredDuringSchedulingIgnoredDuringExecution:: {
                    local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                    // Required. A list of node selector terms. The terms are ORed.
                    nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                  },
                },
                // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                podAffinity:: {
                  local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                  // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                  preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                  // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                  requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                },
                // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                podAntiAffinity:: {
                  local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                  // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                  preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                  // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                  requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                },
              },
              // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
              automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
              // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
              containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
              // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
              dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
              // Use the host's ipc namespace. Optional: Default to false.
              hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
              // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
              hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
              // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
              hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
              // Use the host's pid namespace. Optional: Default to false.
              hostPid(hostPid):: __specMixin({hostPID: hostPid}),
              // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
              hostname(hostname):: __specMixin({hostname: hostname}),
              // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
              imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
              // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
              initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
              // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
              nodeName(nodeName):: __specMixin({nodeName: nodeName}),
              // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
              nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
              // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
              restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
              // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
              schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
              // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
              securityContext:: {
                local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                //
                // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                //
                // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                seLinuxOptions:: {
                  local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                  // Level is SELinux level label that applies to the container.
                  level(level):: __seLinuxOptionsMixin({level: level}),
                  // Role is a SELinux role label that applies to the container.
                  role(role):: __seLinuxOptionsMixin({role: role}),
                  // Type is a SELinux type label that applies to the container.
                  type(type):: __seLinuxOptionsMixin({type: type}),
                  // User is a SELinux user label that applies to the container.
                  user(user):: __seLinuxOptionsMixin({user: user}),
                },
                // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
              },
              // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
              serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
              // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
              serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
              // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
              subdomain(subdomain):: __specMixin({subdomain: subdomain}),
              // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
              terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
              // If specified, the pod's tolerations.
              tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
              // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
              volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
            },
          },
        },
      },
      // PodTemplateList is a list of PodTemplates.
      podTemplateList:: {
        local kind = {kind: "PodTemplateList"},
        default():: apiVersion + kind,
        // List of pod templates
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ReplicationController represents the configuration of a replication controller.
      replicationController:: {
        local kind = {kind: "ReplicationController"},
        default():: apiVersion + kind,
        mixin:: {
          // If the Labels of a ReplicationController are empty, they are defaulted to be the same as the Pod(s) that the replication controller manages. Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the specification of the desired behavior of the replication controller. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
            minReadySeconds(minReadySeconds):: __specMixin({minReadySeconds: minReadySeconds}),
            // Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#what-is-a-replicationcontroller
            replicas(replicas):: __specMixin({replicas: replicas}),
            // Selector is a label query over pods that should match the Replicas count. If Selector is empty, it is defaulted to the labels present on the Pod template. Label keys and values that must match in order to be controlled by this replication controller, if empty defaulted to labels on Pod template. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
            selector(selector):: __specMixin({selector+: selector}),
            // Template is the object that describes the pod that will be created if insufficient replicas are detected. This takes precedence over a TemplateRef. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
          },
        },
      },
      // ReplicationControllerList is a collection of replication controllers.
      replicationControllerList:: {
        local kind = {kind: "ReplicationControllerList"},
        default():: apiVersion + kind,
        // List of replication controllers. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ResourceQuota sets aggregate quota restrictions enforced per namespace
      resourceQuota:: {
        local kind = {kind: "ResourceQuota"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the desired quota. https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Hard is the set of desired hard limits for each named resource. More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/admission_control_resource_quota.md
            hard(hard):: __specMixin({hard+: hard}),
            // A collection of filters that must match each object tracked by a quota. If not specified, the quota matches all objects.
            scopes(scopes):: if std.type(scopes) == "array" then __specMixin({scopes+: scopes}) else __specMixin({scopes: [scopes]}),
          },
        },
      },
      // ResourceQuotaList is a list of ResourceQuota items.
      resourceQuotaList:: {
        local kind = {kind: "ResourceQuotaList"},
        default():: apiVersion + kind,
        // Items is a list of ResourceQuota objects. More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/admission_control_resource_quota.md
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Secret holds secret data of a certain type. The total bytes of the values in the Data field must be less than MaxSecretSize bytes.
      secret:: {
        local kind = {kind: "Secret"},
        default():: apiVersion + kind,
        // Data contains the secret data. Each key must consist of alphanumeric characters, '-', '_' or '.'. The serialized form of the secret data is a base64 encoded string, representing the arbitrary (possibly non-string) data value here. Described in https://tools.ietf.org/html/rfc4648#section-4
        data(data):: {data+: data},
        // stringData allows specifying non-binary secret data in string form. It is provided as a write-only convenience method. All keys and values are merged into the data field on write, overwriting any existing values. It is never output when reading from the API.
        stringData(stringData):: {stringData+: stringData},
        // Used to facilitate programmatic handling of secret data.
        type(type):: {type: type},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // SecretList is a list of Secret.
      secretList:: {
        local kind = {kind: "SecretList"},
        default():: apiVersion + kind,
        // Items is a list of secret objects. More info: https://kubernetes.io/docs/concepts/configuration/secret
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Service is a named abstraction of software service (for example, mysql) consisting of local port (for example 3306) that the proxy listens on, and the selector that determines which pods will answer requests sent through the proxy.
      service:: {
        local kind = {kind: "Service"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the behavior of a service. https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are "None", empty string (""), or a valid IP address. "None" can be specified for headless services when proxying is not required. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
            clusterIp(clusterIp):: __specMixin({clusterIP: clusterIp}),
            // externalIPs is a list of IP addresses for which nodes in the cluster will also accept traffic for this service.  These IPs are not managed by Kubernetes.  The user is responsible for ensuring that traffic arrives at a node with this IP.  A common example is external load-balancers that are not part of the Kubernetes system.
            externalIps(externalIps):: if std.type(externalIps) == "array" then __specMixin({externalIPs+: externalIps}) else __specMixin({externalIPs: [externalIps]}),
            // externalName is the external reference that kubedns or equivalent will return as a CNAME record for this service. No proxying will be involved. Must be a valid DNS name and requires Type to be ExternalName.
            externalName(externalName):: __specMixin({externalName: externalName}),
            // externalTrafficPolicy denotes if this Service desires to route external traffic to local endpoints only. This preserves Source IP and avoids a second hop for LoadBalancer and Nodeport type services.
            externalTrafficPolicy(externalTrafficPolicy):: __specMixin({externalTrafficPolicy: externalTrafficPolicy}),
            // healthCheckNodePort specifies the healthcheck nodePort for the service. If not specified, HealthCheckNodePort is created by the service api backend with the allocated nodePort. Will use user-specified nodePort value if specified by the client. Only effects when Type is set to LoadBalancer and ExternalTrafficPolicy is set to Local.
            healthCheckNodePort(healthCheckNodePort):: __specMixin({healthCheckNodePort: healthCheckNodePort}),
            // Only applies to Service Type: LoadBalancer LoadBalancer will get created with the IP specified in this field. This feature depends on whether the underlying cloud-provider supports specifying the loadBalancerIP when a load balancer is created. This field will be ignored if the cloud-provider does not support the feature.
            loadBalancerIp(loadBalancerIp):: __specMixin({loadBalancerIP: loadBalancerIp}),
            // If specified and supported by the platform, this will restrict traffic through the cloud-provider load-balancer will be restricted to the specified client IPs. This field will be ignored if the cloud-provider does not support the feature." More info: https://kubernetes.io/docs/tasks/access-application-cluster/configure-cloud-provider-firewall/
            loadBalancerSourceRanges(loadBalancerSourceRanges):: if std.type(loadBalancerSourceRanges) == "array" then __specMixin({loadBalancerSourceRanges+: loadBalancerSourceRanges}) else __specMixin({loadBalancerSourceRanges: [loadBalancerSourceRanges]}),
            // The list of ports that are exposed by this service. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
            ports(ports):: if std.type(ports) == "array" then __specMixin({ports+: ports}) else __specMixin({ports: [ports]}),
            // Route service traffic to pods with label keys and values matching this selector. If empty or not present, the service is assumed to have an external process managing its endpoints, which Kubernetes will not modify. Only applies to types ClusterIP, NodePort, and LoadBalancer. Ignored if type is ExternalName. More info: https://kubernetes.io/docs/concepts/services-networking/service/
            selector(selector):: __specMixin({selector+: selector}),
            // Supports "ClientIP" and "None". Used to maintain session affinity. Enable client IP based session affinity. Must be ClientIP or None. Defaults to None. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies
            sessionAffinity(sessionAffinity):: __specMixin({sessionAffinity: sessionAffinity}),
            // type determines how the Service is exposed. Defaults to ClusterIP. Valid options are ExternalName, ClusterIP, NodePort, and LoadBalancer. "ExternalName" maps to the specified externalName. "ClusterIP" allocates a cluster-internal IP address for load-balancing to endpoints. Endpoints are determined by the selector or if that is not specified, by manual construction of an Endpoints object. If clusterIP is "None", no virtual IP is allocated and the endpoints are published as a set of endpoints rather than a stable IP. "NodePort" builds on ClusterIP and allocates a port on every node which routes to the clusterIP. "LoadBalancer" builds on NodePort and creates an external load-balancer (if supported in the current cloud) which routes to the clusterIP. More info: https://kubernetes.io/docs/concepts/services-networking/service/#publishing-services---service-types
            type(type):: __specMixin({type: type}),
          },
        },
      },
      // ServiceAccount binds together: * a name, understood by users, and perhaps by peripheral systems, for an identity * a principal that can be authenticated and authorized * a set of secrets
      serviceAccount:: {
        local kind = {kind: "ServiceAccount"},
        default():: apiVersion + kind,
        // AutomountServiceAccountToken indicates whether pods running as this service account should have an API token automatically mounted. Can be overridden at the pod level.
        automountServiceAccountToken(automountServiceAccountToken):: {automountServiceAccountToken: automountServiceAccountToken},
        // ImagePullSecrets is a list of references to secrets in the same namespace to use for pulling any images in pods that reference this ServiceAccount. ImagePullSecrets are distinct from Secrets because Secrets can be mounted in the pod, but ImagePullSecrets are only accessed by the kubelet. More info: https://kubernetes.io/docs/concepts/containers/images/#specifying-imagepullsecrets-on-a-pod
        imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then {imagePullSecrets+: imagePullSecrets} else {imagePullSecrets: [imagePullSecrets]},
        // Secrets is the list of secrets allowed to be used by pods running using this ServiceAccount. More info: https://kubernetes.io/docs/concepts/configuration/secret
        secrets(secrets):: if std.type(secrets) == "array" then {secrets+: secrets} else {secrets: [secrets]},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // ServiceAccountList is a list of ServiceAccount objects
      serviceAccountList:: {
        local kind = {kind: "ServiceAccountList"},
        default():: apiVersion + kind,
        // List of ServiceAccounts. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ServiceList holds a list of services.
      serviceList:: {
        local kind = {kind: "ServiceList"},
        default():: apiVersion + kind,
        // List of services
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  extensions:: {
    v1beta1:: {
      local apiVersion = {apiVersion: "extensions/v1beta1"},
      // DaemonSet represents the configuration of a daemon set.
      daemonSet:: {
        local kind = {kind: "DaemonSet"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // The desired behavior of this daemon set. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // The minimum number of seconds for which a newly created DaemonSet pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready).
            minReadySeconds(minReadySeconds):: __specMixin({minReadySeconds: minReadySeconds}),
            // A label query over pods that are managed by the daemon set. Must match in order to be controlled. If empty, defaulted to labels on Pod template. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // An object that describes the pod that will be created. The DaemonSet will create exactly one copy of this pod on every node that matches the template's node selector (or on every node if no node selector is specified). More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
            // An update strategy to replace existing DaemonSet pods with new pods.
            updateStrategy:: {
              local __updateStrategyMixin(updateStrategy) = __specMixin({updateStrategy+: updateStrategy}),
              // Rolling update config params. Present only if type = "RollingUpdate".
              rollingUpdate:: {
                local __rollingUpdateMixin(rollingUpdate) = __updateStrategyMixin({rollingUpdate+: rollingUpdate}),
                // The maximum number of DaemonSet pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of total number of DaemonSet pods at the start of the update (ex: 10%). Absolute number is calculated from percentage by rounding up. This cannot be 0. Default value is 1. Example: when this is set to 30%, at most 30% of the total number of nodes that should be running the daemon pod (i.e. status.desiredNumberScheduled) can have their pods stopped for an update at any given time. The update starts by stopping at most 30% of those DaemonSet pods and then brings up new DaemonSet pods in their place. Once the new pods are available, it then proceeds onto other DaemonSet pods, thus ensuring that at least 70% of original number of DaemonSet pods are available at all times during the update.
                maxUnavailable:: {
                  local __maxUnavailableMixin(maxUnavailable) = __rollingUpdateMixin({maxUnavailable+: maxUnavailable}),
                },
              },
              // Type of daemon set update. Can be "RollingUpdate" or "OnDelete". Default is OnDelete.
              type(type):: __updateStrategyMixin({type: type}),
            },
          },
        },
      },
      // DaemonSetList is a collection of daemon sets.
      daemonSetList:: {
        local kind = {kind: "DaemonSetList"},
        default():: apiVersion + kind,
        // A list of daemon sets.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Deployment enables declarative updates for Pods and ReplicaSets.
      deployment:: {
        local kind = {kind: "Deployment"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior of the Deployment.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
            minReadySeconds(minReadySeconds):: __specMixin({minReadySeconds: minReadySeconds}),
            // Indicates that the deployment is paused and will not be processed by the deployment controller.
            paused(paused):: __specMixin({paused: paused}),
            // The maximum time in seconds for a deployment to make progress before it is considered to be failed. The deployment controller will continue to process failed deployments and a condition with a ProgressDeadlineExceeded reason will be surfaced in the deployment status. Once autoRollback is implemented, the deployment controller will automatically rollback failed deployments. Note that progress will not be estimated during the time a deployment is paused. This is not set by default.
            progressDeadlineSeconds(progressDeadlineSeconds):: __specMixin({progressDeadlineSeconds: progressDeadlineSeconds}),
            // Number of desired pods. This is a pointer to distinguish between explicit zero and not specified. Defaults to 1.
            replicas(replicas):: __specMixin({replicas: replicas}),
            // The number of old ReplicaSets to retain to allow rollback. This is a pointer to distinguish between explicit zero and not specified.
            revisionHistoryLimit(revisionHistoryLimit):: __specMixin({revisionHistoryLimit: revisionHistoryLimit}),
            // The config this deployment is rolling back to. Will be cleared after rollback is done.
            rollbackTo:: {
              local __rollbackToMixin(rollbackTo) = __specMixin({rollbackTo+: rollbackTo}),
              // The revision to rollback to. If set to 0, rollbck to the last revision.
              revision(revision):: __rollbackToMixin({revision: revision}),
            },
            // Label selector for pods. Existing ReplicaSets whose pods are selected by this will be the ones affected by this deployment.
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // The deployment strategy to use to replace existing pods with new ones.
            strategy:: {
              local __strategyMixin(strategy) = __specMixin({strategy+: strategy}),
              // Rolling update config params. Present only if DeploymentStrategyType = RollingUpdate.
              rollingUpdate:: {
                local __rollingUpdateMixin(rollingUpdate) = __strategyMixin({rollingUpdate+: rollingUpdate}),
                // The maximum number of pods that can be scheduled above the desired number of pods. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). This can not be 0 if MaxUnavailable is 0. Absolute number is calculated from percentage by rounding up. By default, a value of 1 is used. Example: when this is set to 30%, the new RC can be scaled up immediately when the rolling update starts, such that the total number of old and new pods do not exceed 130% of desired pods. Once old pods have been killed, new RC can be scaled up further, ensuring that total number of pods running at any time during the update is atmost 130% of desired pods.
                maxSurge:: {
                  local __maxSurgeMixin(maxSurge) = __rollingUpdateMixin({maxSurge+: maxSurge}),
                },
                // The maximum number of pods that can be unavailable during the update. Value can be an absolute number (ex: 5) or a percentage of desired pods (ex: 10%). Absolute number is calculated from percentage by rounding down. This can not be 0 if MaxSurge is 0. By default, a fixed value of 1 is used. Example: when this is set to 30%, the old RC can be scaled down to 70% of desired pods immediately when the rolling update starts. Once new pods are ready, old RC can be scaled down further, followed by scaling up the new RC, ensuring that the total number of pods available at all times during the update is at least 70% of desired pods.
                maxUnavailable:: {
                  local __maxUnavailableMixin(maxUnavailable) = __rollingUpdateMixin({maxUnavailable+: maxUnavailable}),
                },
              },
              // Type of deployment. Can be "Recreate" or "RollingUpdate". Default is RollingUpdate.
              type(type):: __strategyMixin({type: type}),
            },
            // Template describes the pods that will be created.
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
          },
        },
      },
      // DeploymentList is a list of Deployments.
      deploymentList:: {
        local kind = {kind: "DeploymentList"},
        default():: apiVersion + kind,
        // Items is the list of Deployments.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // DeploymentRollback stores the information required to rollback a deployment.
      deploymentRollback:: {
        local kind = {kind: "DeploymentRollback"},
        default():: apiVersion + kind,
        // Required: This must match the Name of a deployment.
        name(name):: {name: name},
        // The annotations to be updated to a deployment
        updatedAnnotations(updatedAnnotations):: {updatedAnnotations+: updatedAnnotations},
        mixin:: {
          // The config of this deployment rollback.
          rollbackTo:: {
            local __rollbackToMixin(rollbackTo) = {rollbackTo+: rollbackTo},
            // The revision to rollback to. If set to 0, rollbck to the last revision.
            revision(revision):: __rollbackToMixin({revision: revision}),
          },
        },
      },
      // Ingress is a collection of rules that allow inbound connections to reach the endpoints defined by a backend. An Ingress can be configured to give services externally-reachable urls, load balance traffic, terminate SSL, offer name based virtual hosting etc.
      ingress:: {
        local kind = {kind: "Ingress"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec is the desired state of the Ingress. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // A default backend capable of servicing requests that don't match any rule. At least one of 'backend' or 'rules' must be specified. This field is optional to allow the loadbalancer controller or defaulting logic to specify a global default.
            backend:: {
              local __backendMixin(backend) = __specMixin({backend+: backend}),
              // Specifies the name of the referenced service.
              serviceName(serviceName):: __backendMixin({serviceName: serviceName}),
              // Specifies the port of the referenced service.
              servicePort:: {
                local __servicePortMixin(servicePort) = __backendMixin({servicePort+: servicePort}),
              },
            },
            // A list of host rules used to configure the Ingress. If unspecified, or no rule matches, all traffic is sent to the default backend.
            rules(rules):: if std.type(rules) == "array" then __specMixin({rules+: rules}) else __specMixin({rules: [rules]}),
            // TLS configuration. Currently the Ingress only supports a single TLS port, 443. If multiple members of this list specify different hosts, they will be multiplexed on the same port according to the hostname specified through the SNI TLS extension, if the ingress controller fulfilling the ingress supports SNI.
            tls(tls):: if std.type(tls) == "array" then __specMixin({tls+: tls}) else __specMixin({tls: [tls]}),
          },
        },
      },
      // IngressList is a collection of Ingress.
      ingressList:: {
        local kind = {kind: "IngressList"},
        default():: apiVersion + kind,
        // Items is the list of Ingress.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      //
      networkPolicy:: {
        local kind = {kind: "NetworkPolicy"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior for this NetworkPolicy.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // List of ingress rules to be applied to the selected pods. Traffic is allowed to a pod if namespace.networkPolicy.ingress.isolation is undefined and cluster policy allows it, OR if the traffic source is the pod's local node, OR if the traffic matches at least one ingress rule across all of the NetworkPolicy objects whose podSelector matches the pod. If this field is empty then this NetworkPolicy does not affect ingress isolation. If this field is present and contains at least one rule, this policy allows any traffic which matches at least one of the ingress rules in this list.
            ingress(ingress):: if std.type(ingress) == "array" then __specMixin({ingress+: ingress}) else __specMixin({ingress: [ingress]}),
            // Selects the pods to which this NetworkPolicy object applies.  The array of ingress rules is applied to any pods selected by this field. Multiple network policies can select the same set of pods.  In this case, the ingress rules for each are combined additively. This field is NOT optional and follows standard label selector semantics. An empty podSelector matches all pods in this namespace.
            podSelector:: {
              local __podSelectorMixin(podSelector) = __specMixin({podSelector+: podSelector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __podSelectorMixin({matchExpressions+: matchExpressions}) else __podSelectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __podSelectorMixin({matchLabels+: matchLabels}),
            },
          },
        },
      },
      // Network Policy List is a list of NetworkPolicy objects.
      networkPolicyList:: {
        local kind = {kind: "NetworkPolicyList"},
        default():: apiVersion + kind,
        // Items is a list of schema objects.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Pod Security Policy governs the ability to make requests that affect the Security Context that will be applied to a pod and container.
      podSecurityPolicy:: {
        local kind = {kind: "PodSecurityPolicy"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // spec defines the policy enforced.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // AllowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field may be added at the pod author's discretion. You must not list a capability in both AllowedCapabilities and RequiredDropCapabilities.
            allowedCapabilities(allowedCapabilities):: if std.type(allowedCapabilities) == "array" then __specMixin({allowedCapabilities+: allowedCapabilities}) else __specMixin({allowedCapabilities: [allowedCapabilities]}),
            // DefaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec specifically drops the capability.  You may not list a capabiility in both DefaultAddCapabilities and RequiredDropCapabilities.
            defaultAddCapabilities(defaultAddCapabilities):: if std.type(defaultAddCapabilities) == "array" then __specMixin({defaultAddCapabilities+: defaultAddCapabilities}) else __specMixin({defaultAddCapabilities: [defaultAddCapabilities]}),
            // FSGroup is the strategy that will dictate what fs group is used by the SecurityContext.
            fsGroup:: {
              local __fsGroupMixin(fsGroup) = __specMixin({fsGroup+: fsGroup}),
              // Ranges are the allowed ranges of fs groups.  If you would like to force a single fs group then supply a single range with the same start and end.
              ranges(ranges):: if std.type(ranges) == "array" then __fsGroupMixin({ranges+: ranges}) else __fsGroupMixin({ranges: [ranges]}),
              // Rule is the strategy that will dictate what FSGroup is used in the SecurityContext.
              rule(rule):: __fsGroupMixin({rule: rule}),
            },
            // hostIPC determines if the policy allows the use of HostIPC in the pod spec.
            hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
            // hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
            hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
            // hostPID determines if the policy allows the use of HostPID in the pod spec.
            hostPid(hostPid):: __specMixin({hostPID: hostPid}),
            // hostPorts determines which host port ranges are allowed to be exposed.
            hostPorts(hostPorts):: if std.type(hostPorts) == "array" then __specMixin({hostPorts+: hostPorts}) else __specMixin({hostPorts: [hostPorts]}),
            // privileged determines if a pod can request to be run as privileged.
            privileged(privileged):: __specMixin({privileged: privileged}),
            // ReadOnlyRootFilesystem when set to true will force containers to run with a read only root file system.  If the container specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the container may run with a read only root file system if it wishes but it will not be forced to.
            readOnlyRootFilesystem(readOnlyRootFilesystem):: __specMixin({readOnlyRootFilesystem: readOnlyRootFilesystem}),
            // RequiredDropCapabilities are the capabilities that will be dropped from the container.  These are required to be dropped and cannot be added.
            requiredDropCapabilities(requiredDropCapabilities):: if std.type(requiredDropCapabilities) == "array" then __specMixin({requiredDropCapabilities+: requiredDropCapabilities}) else __specMixin({requiredDropCapabilities: [requiredDropCapabilities]}),
            // runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
            runAsUser:: {
              local __runAsUserMixin(runAsUser) = __specMixin({runAsUser+: runAsUser}),
              // Ranges are the allowed ranges of uids that may be used.
              ranges(ranges):: if std.type(ranges) == "array" then __runAsUserMixin({ranges+: ranges}) else __runAsUserMixin({ranges: [ranges]}),
              // Rule is the strategy that will dictate the allowable RunAsUser values that may be set.
              rule(rule):: __runAsUserMixin({rule: rule}),
            },
            // seLinux is the strategy that will dictate the allowable labels that may be set.
            seLinux:: {
              local __seLinuxMixin(seLinux) = __specMixin({seLinux+: seLinux}),
              // type is the strategy that will dictate the allowable labels that may be set.
              rule(rule):: __seLinuxMixin({rule: rule}),
              // seLinuxOptions required to run as; required for MustRunAs More info: https://github.com/kubernetes/community/blob/master/contributors/design-proposals/security_context.md
              seLinuxOptions:: {
                local __seLinuxOptionsMixin(seLinuxOptions) = __seLinuxMixin({seLinuxOptions+: seLinuxOptions}),
                // Level is SELinux level label that applies to the container.
                level(level):: __seLinuxOptionsMixin({level: level}),
                // Role is a SELinux role label that applies to the container.
                role(role):: __seLinuxOptionsMixin({role: role}),
                // Type is a SELinux type label that applies to the container.
                type(type):: __seLinuxOptionsMixin({type: type}),
                // User is a SELinux user label that applies to the container.
                user(user):: __seLinuxOptionsMixin({user: user}),
              },
            },
            // SupplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
            supplementalGroups:: {
              local __supplementalGroupsMixin(supplementalGroups) = __specMixin({supplementalGroups+: supplementalGroups}),
              // Ranges are the allowed ranges of supplemental groups.  If you would like to force a single supplemental group then supply a single range with the same start and end.
              ranges(ranges):: if std.type(ranges) == "array" then __supplementalGroupsMixin({ranges+: ranges}) else __supplementalGroupsMixin({ranges: [ranges]}),
              // Rule is the strategy that will dictate what supplemental groups is used in the SecurityContext.
              rule(rule):: __supplementalGroupsMixin({rule: rule}),
            },
            // volumes is a white list of allowed volume plugins.  Empty indicates that all plugins may be used.
            volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
          },
        },
      },
      // Pod Security Policy List is a list of PodSecurityPolicy objects.
      podSecurityPolicyList:: {
        local kind = {kind: "PodSecurityPolicyList"},
        default():: apiVersion + kind,
        // Items is a list of schema objects.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ReplicaSet represents the configuration of a ReplicaSet.
      replicaSet:: {
        local kind = {kind: "ReplicaSet"},
        default():: apiVersion + kind,
        mixin:: {
          // If the Labels of a ReplicaSet are empty, they are defaulted to be the same as the Pod(s) that the ReplicaSet manages. Standard object's metadata. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Spec defines the specification of the desired behavior of the ReplicaSet. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Minimum number of seconds for which a newly created pod should be ready without any of its container crashing, for it to be considered available. Defaults to 0 (pod will be considered available as soon as it is ready)
            minReadySeconds(minReadySeconds):: __specMixin({minReadySeconds: minReadySeconds}),
            // Replicas is the number of desired replicas. This is a pointer to distinguish between explicit zero and unspecified. Defaults to 1. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller/#what-is-a-replicationcontroller
            replicas(replicas):: __specMixin({replicas: replicas}),
            // Selector is a label query over pods that should match the replica count. If the selector is empty, it is defaulted to the labels present on the pod template. Label keys and values that must match in order to be controlled by this replica set. More info: https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // Template is the object that describes the pod that will be created if insufficient replicas are detected. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller#pod-template
            template:: {
              local __templateMixin(template) = __specMixin({template+: template}),
              // Specification of the desired behavior of the pod. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#spec-and-status
              spec:: {
                local __specMixin(spec) = __templateMixin({spec+: spec}),
                // Optional duration in seconds the pod may be active on the node relative to StartTime before the system will actively try to mark it failed and kill associated containers. Value must be a positive integer.
                activeDeadlineSeconds(activeDeadlineSeconds):: __specMixin({activeDeadlineSeconds: activeDeadlineSeconds}),
                // If specified, the pod's scheduling constraints
                affinity:: {
                  local __affinityMixin(affinity) = __specMixin({affinity+: affinity}),
                  // Describes node affinity scheduling rules for the pod.
                  nodeAffinity:: {
                    local __nodeAffinityMixin(nodeAffinity) = __affinityMixin({nodeAffinity+: nodeAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node matches the corresponding matchExpressions; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __nodeAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to an update), the system may or may not try to eventually evict the pod from its node.
                    requiredDuringSchedulingIgnoredDuringExecution:: {
                      local __requiredDuringSchedulingIgnoredDuringExecutionMixin(requiredDuringSchedulingIgnoredDuringExecution) = __nodeAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}),
                      // Required. A list of node selector terms. The terms are ORed.
                      nodeSelectorTerms(nodeSelectorTerms):: if std.type(nodeSelectorTerms) == "array" then __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms+: nodeSelectorTerms}) else __requiredDuringSchedulingIgnoredDuringExecutionMixin({nodeSelectorTerms: [nodeSelectorTerms]}),
                    },
                  },
                  // Describes pod affinity scheduling rules (e.g. co-locate this pod in the same node, zone, etc. as some other pod(s)).
                  podAffinity:: {
                    local __podAffinityMixin(podAffinity) = __affinityMixin({podAffinity+: podAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                  // Describes pod anti-affinity scheduling rules (e.g. avoid putting this pod in the same node, zone, etc. as some other pod(s)).
                  podAntiAffinity:: {
                    local __podAntiAffinityMixin(podAntiAffinity) = __affinityMixin({podAntiAffinity+: podAntiAffinity}),
                    // The scheduler will prefer to schedule pods to nodes that satisfy the anti-affinity expressions specified by this field, but it may choose a node that violates one or more of the expressions. The node that is most preferred is the one with the greatest sum of weights, i.e. for each node that meets all of the scheduling requirements (resource request, requiredDuringScheduling anti-affinity expressions, etc.), compute a sum by iterating through the elements of this field and adding "weight" to the sum if the node has pods which matches the corresponding podAffinityTerm; the node(s) with the highest sum are the most preferred.
                    preferredDuringSchedulingIgnoredDuringExecution(preferredDuringSchedulingIgnoredDuringExecution):: if std.type(preferredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution+: preferredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({preferredDuringSchedulingIgnoredDuringExecution: [preferredDuringSchedulingIgnoredDuringExecution]}),
                    // NOT YET IMPLEMENTED. TODO: Uncomment field once it is implemented. If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system will try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied. RequiredDuringSchedulingRequiredDuringExecution []PodAffinityTerm  `json:"requiredDuringSchedulingRequiredDuringExecution,omitempty"` If the anti-affinity requirements specified by this field are not met at scheduling time, the pod will not be scheduled onto the node. If the anti-affinity requirements specified by this field cease to be met at some point during pod execution (e.g. due to a pod label update), the system may or may not try to eventually evict the pod from its node. When there are multiple elements, the lists of nodes corresponding to each podAffinityTerm are intersected, i.e. all terms must be satisfied.
                    requiredDuringSchedulingIgnoredDuringExecution(requiredDuringSchedulingIgnoredDuringExecution):: if std.type(requiredDuringSchedulingIgnoredDuringExecution) == "array" then __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution+: requiredDuringSchedulingIgnoredDuringExecution}) else __podAntiAffinityMixin({requiredDuringSchedulingIgnoredDuringExecution: [requiredDuringSchedulingIgnoredDuringExecution]}),
                  },
                },
                // AutomountServiceAccountToken indicates whether a service account token should be automatically mounted.
                automountServiceAccountToken(automountServiceAccountToken):: __specMixin({automountServiceAccountToken: automountServiceAccountToken}),
                // List of containers belonging to the pod. Containers cannot currently be added or removed. There must be at least one container in a Pod. Cannot be updated.
                containers(containers):: if std.type(containers) == "array" then __specMixin({containers+: containers}) else __specMixin({containers: [containers]}),
                // Set DNS policy for containers within the pod. One of 'ClusterFirstWithHostNet', 'ClusterFirst' or 'Default'. Defaults to "ClusterFirst". To have DNS options set along with hostNetwork, you have to specify DNS policy explicitly to 'ClusterFirstWithHostNet'.
                dnsPolicy(dnsPolicy):: __specMixin({dnsPolicy: dnsPolicy}),
                // Use the host's ipc namespace. Optional: Default to false.
                hostIpc(hostIpc):: __specMixin({hostIPC: hostIpc}),
                // HostAliases is an optional list of hosts and IPs that will be injected into the pod's hosts file if specified. This is only valid for non-hostNetwork pods.
                hostMappings(hostMappings):: if std.type(hostMappings) == "array" then __specMixin({hostMappings+: hostMappings}) else __specMixin({hostMappings: [hostMappings]}),
                // Host networking requested for this pod. Use the host's network namespace. If this option is set, the ports that will be used must be specified. Default to false.
                hostNetwork(hostNetwork):: __specMixin({hostNetwork: hostNetwork}),
                // Use the host's pid namespace. Optional: Default to false.
                hostPid(hostPid):: __specMixin({hostPID: hostPid}),
                // Specifies the hostname of the Pod If not specified, the pod's hostname will be set to a system-defined value.
                hostname(hostname):: __specMixin({hostname: hostname}),
                // ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod
                imagePullSecrets(imagePullSecrets):: if std.type(imagePullSecrets) == "array" then __specMixin({imagePullSecrets+: imagePullSecrets}) else __specMixin({imagePullSecrets: [imagePullSecrets]}),
                // List of initialization containers belonging to the pod. Init containers are executed in order prior to containers being started. If any init container fails, the pod is considered to have failed and is handled according to its restartPolicy. The name for an init container or normal container must be unique among all containers. Init containers may not have Lifecycle actions, Readiness probes, or Liveness probes. The resourceRequirements of an init container are taken into account during scheduling by finding the highest request/limit for each resource type, and then using the max of of that value or the sum of the normal containers. Limits are applied to init containers in a similar fashion. Init containers cannot currently be added or removed. Cannot be updated. More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
                initContainers(initContainers):: if std.type(initContainers) == "array" then __specMixin({initContainers+: initContainers}) else __specMixin({initContainers: [initContainers]}),
                // NodeName is a request to schedule this pod onto a specific node. If it is non-empty, the scheduler simply schedules this pod onto that node, assuming that it fits resource requirements.
                nodeName(nodeName):: __specMixin({nodeName: nodeName}),
                // NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/
                nodeSelector(nodeSelector):: __specMixin({nodeSelector+: nodeSelector}),
                // Restart policy for all containers within the pod. One of Always, OnFailure, Never. Default to Always. More info: https://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy
                restartPolicy(restartPolicy):: __specMixin({restartPolicy: restartPolicy}),
                // If specified, the pod will be dispatched by specified scheduler. If not specified, the pod will be dispatched by default scheduler.
                schedulerName(schedulerName):: __specMixin({schedulerName: schedulerName}),
                // SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.
                securityContext:: {
                  local __securityContextMixin(securityContext) = __specMixin({securityContext+: securityContext}),
                  // A special supplemental group that applies to all containers in a pod. Some volume types allow the Kubelet to change the ownership of that volume to be owned by the pod:
                  //
                  // 1. The owning GID will be the FSGroup 2. The setgid bit is set (new files created in the volume will be owned by FSGroup) 3. The permission bits are OR'd with rw-rw----
                  //
                  // If unset, the Kubelet will not modify the ownership and permissions of any volume.
                  fsGroup(fsGroup):: __securityContextMixin({fsGroup: fsGroup}),
                  // Indicates that the container must run as a non-root user. If true, the Kubelet will validate the image at runtime to ensure that it does not run as UID 0 (root) and fail to start the container if it does. If unset or false, no such validation will be performed. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence.
                  runAsNonRoot(runAsNonRoot):: __securityContextMixin({runAsNonRoot: runAsNonRoot}),
                  // The UID to run the entrypoint of the container process. Defaults to user specified in image metadata if unspecified. May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  runAsUser(runAsUser):: __securityContextMixin({runAsUser: runAsUser}),
                  // The SELinux context to be applied to all containers. If unspecified, the container runtime will allocate a random SELinux context for each container.  May also be set in SecurityContext.  If set in both SecurityContext and PodSecurityContext, the value specified in SecurityContext takes precedence for that container.
                  seLinuxOptions:: {
                    local __seLinuxOptionsMixin(seLinuxOptions) = __securityContextMixin({seLinuxOptions+: seLinuxOptions}),
                    // Level is SELinux level label that applies to the container.
                    level(level):: __seLinuxOptionsMixin({level: level}),
                    // Role is a SELinux role label that applies to the container.
                    role(role):: __seLinuxOptionsMixin({role: role}),
                    // Type is a SELinux type label that applies to the container.
                    type(type):: __seLinuxOptionsMixin({type: type}),
                    // User is a SELinux user label that applies to the container.
                    user(user):: __seLinuxOptionsMixin({user: user}),
                  },
                  // A list of groups applied to the first process run in each container, in addition to the container's primary GID.  If unspecified, no groups will be added to any container.
                  supplementalGroups(supplementalGroups):: if std.type(supplementalGroups) == "array" then __securityContextMixin({supplementalGroups+: supplementalGroups}) else __securityContextMixin({supplementalGroups: [supplementalGroups]}),
                },
                // DeprecatedServiceAccount is a depreciated alias for ServiceAccountName. Deprecated: Use serviceAccountName instead.
                serviceAccount(serviceAccount):: __specMixin({serviceAccount: serviceAccount}),
                // ServiceAccountName is the name of the ServiceAccount to use to run this pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/
                serviceAccountName(serviceAccountName):: __specMixin({serviceAccountName: serviceAccountName}),
                // If specified, the fully qualified Pod hostname will be "<hostname>.<subdomain>.<pod namespace>.svc.<cluster domain>". If not specified, the pod will not have a domainname at all.
                subdomain(subdomain):: __specMixin({subdomain: subdomain}),
                // Optional duration in seconds the pod needs to terminate gracefully. May be decreased in delete request. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period will be used instead. The grace period is the duration in seconds after the processes running in the pod are sent a termination signal and the time when the processes are forcibly halted with a kill signal. Set this value longer than the expected cleanup time for your process. Defaults to 30 seconds.
                terminationGracePeriodSeconds(terminationGracePeriodSeconds):: __specMixin({terminationGracePeriodSeconds: terminationGracePeriodSeconds}),
                // If specified, the pod's tolerations.
                tolerations(tolerations):: if std.type(tolerations) == "array" then __specMixin({tolerations+: tolerations}) else __specMixin({tolerations: [tolerations]}),
                // List of volumes that can be mounted by containers belonging to the pod. More info: https://kubernetes.io/docs/concepts/storage/volumes
                volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
              },
            },
          },
        },
      },
      // ReplicaSetList is a collection of ReplicaSets.
      replicaSetList:: {
        local kind = {kind: "ReplicaSetList"},
        default():: apiVersion + kind,
        // List of ReplicaSets. More info: https://kubernetes.io/docs/concepts/workloads/controllers/replicationcontroller
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // represents a scaling request for a resource.
      scale:: {
        local kind = {kind: "Scale"},
        default():: apiVersion + kind,
        mixin:: {
          // Standard object metadata; More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // defines the behavior of the scale. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#spec-and-status.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // desired number of instances for the scaled object.
            replicas(replicas):: __specMixin({replicas: replicas}),
          },
        },
      },
      // A ThirdPartyResource is a generic representation of a resource, it is used by add-ons and plugins to add new resource types to the API.  It consists of one or more Versions of the api.
      thirdPartyResource:: {
        local kind = {kind: "ThirdPartyResource"},
        default():: apiVersion + kind,
        // Description is the description of this object.
        description(description):: {description: description},
        // Versions are versions for this third party object
        versions(versions):: if std.type(versions) == "array" then {versions+: versions} else {versions: [versions]},
        mixin:: {
          // Standard object metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // ThirdPartyResourceList is a list of ThirdPartyResources.
      thirdPartyResourceList:: {
        local kind = {kind: "ThirdPartyResourceList"},
        default():: apiVersion + kind,
        // Items is the list of ThirdPartyResources.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  meta:: {
    v1:: {
      local apiVersion = {apiVersion: "meta/v1"},
    },
  },
  policy:: {
    v1beta1:: {
      local apiVersion = {apiVersion: "policy/v1beta1"},
      // Eviction evicts a pod from its node subject to certain policies and safety constraints. This is a subresource of Pod.  A request to cause such an eviction is created by POSTing to .../pods/<pod name>/evictions.
      eviction:: {
        local kind = {kind: "Eviction"},
        default():: apiVersion + kind,
        mixin:: {
          // DeleteOptions may be provided
          deleteOptions:: {
            local __deleteOptionsMixin(deleteOptions) = {deleteOptions+: deleteOptions},
            // The duration in seconds before the object should be deleted. Value must be non-negative integer. The value zero indicates delete immediately. If this value is nil, the default grace period for the specified type will be used. Defaults to a per object value if not specified. zero means delete immediately.
            gracePeriodSeconds(gracePeriodSeconds):: __deleteOptionsMixin({gracePeriodSeconds: gracePeriodSeconds}),
            // Deprecated: please use the PropagationPolicy, this field will be deprecated in 1.7. Should the dependent objects be orphaned. If true/false, the "orphan" finalizer will be added to/removed from the object's finalizers list. Either this field or PropagationPolicy may be set, but not both.
            orphanDependents(orphanDependents):: __deleteOptionsMixin({orphanDependents: orphanDependents}),
            // Must be fulfilled before a deletion is carried out. If not possible, a 409 Conflict status will be returned.
            preconditions:: {
              local __preconditionsMixin(preconditions) = __deleteOptionsMixin({preconditions+: preconditions}),
              // Specifies the target UID.
              uid(uid):: __preconditionsMixin({uid: uid}),
            },
            // Whether and how garbage collection will be performed. Either this field or OrphanDependents may be set, but not both. The default policy is decided by the existing finalizer set in the metadata.finalizers and the resource-specific default policy.
            propagationPolicy(propagationPolicy):: __deleteOptionsMixin({propagationPolicy: propagationPolicy}),
          },
          // ObjectMeta describes the pod that is being evicted.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // PodDisruptionBudget is an object to define the max disruption that can be caused to a collection of pods
      podDisruptionBudget:: {
        local kind = {kind: "PodDisruptionBudget"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // Specification of the desired behavior of the PodDisruptionBudget.
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // An eviction is allowed if at least "minAvailable" pods selected by "selector" will still be available after the eviction, i.e. even in the absence of the evicted pod.  So for example you can prevent all voluntary evictions by specifying "100%".
            minAvailable:: {
              local __minAvailableMixin(minAvailable) = __specMixin({minAvailable+: minAvailable}),
            },
            // Label query over pods whose evictions are managed by the disruption budget.
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
          },
        },
      },
      // PodDisruptionBudgetList is a collection of PodDisruptionBudgets.
      podDisruptionBudgetList:: {
        local kind = {kind: "PodDisruptionBudgetList"},
        default():: apiVersion + kind,
        //
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  rbac:: {
    v1alpha1:: {
      local apiVersion = {apiVersion: "rbac/v1alpha1"},
      // ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
      clusterRole:: {
        local kind = {kind: "ClusterRole"},
        default():: apiVersion + kind,
        // Rules holds all the PolicyRules for this ClusterRole
        rules(rules):: if std.type(rules) == "array" then {rules+: rules} else {rules: [rules]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
      clusterRoleBinding:: {
        local kind = {kind: "ClusterRoleBinding"},
        default():: apiVersion + kind,
        // Subjects holds references to the objects the role applies to.
        subjects(subjects):: if std.type(subjects) == "array" then {subjects+: subjects} else {subjects: [subjects]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
          roleRef:: {
            local __roleRefMixin(roleRef) = {roleRef+: roleRef},
            // APIGroup is the group for the resource being referenced
            apiGroup(apiGroup):: __roleRefMixin({apiGroup: apiGroup}),
            // Name is the name of resource being referenced
            name(name):: __roleRefMixin({name: name}),
          },
        },
      },
      // ClusterRoleBindingList is a collection of ClusterRoleBindings
      clusterRoleBindingList:: {
        local kind = {kind: "ClusterRoleBindingList"},
        default():: apiVersion + kind,
        // Items is a list of ClusterRoleBindings
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ClusterRoleList is a collection of ClusterRoles
      clusterRoleList:: {
        local kind = {kind: "ClusterRoleList"},
        default():: apiVersion + kind,
        // Items is a list of ClusterRoles
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
      role:: {
        local kind = {kind: "Role"},
        default():: apiVersion + kind,
        // Rules holds all the PolicyRules for this Role
        rules(rules):: if std.type(rules) == "array" then {rules+: rules} else {rules: [rules]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
      roleBinding:: {
        local kind = {kind: "RoleBinding"},
        default():: apiVersion + kind,
        // Subjects holds references to the objects the role applies to.
        subjects(subjects):: if std.type(subjects) == "array" then {subjects+: subjects} else {subjects: [subjects]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
          roleRef:: {
            local __roleRefMixin(roleRef) = {roleRef+: roleRef},
            // APIGroup is the group for the resource being referenced
            apiGroup(apiGroup):: __roleRefMixin({apiGroup: apiGroup}),
            // Name is the name of resource being referenced
            name(name):: __roleRefMixin({name: name}),
          },
        },
      },
      // RoleBindingList is a collection of RoleBindings
      roleBindingList:: {
        local kind = {kind: "RoleBindingList"},
        default():: apiVersion + kind,
        // Items is a list of RoleBindings
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // RoleList is a collection of Roles
      roleList:: {
        local kind = {kind: "RoleList"},
        default():: apiVersion + kind,
        // Items is a list of Roles
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
    v1beta1:: {
      local apiVersion = {apiVersion: "rbac/v1beta1"},
      // ClusterRole is a cluster level, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding or ClusterRoleBinding.
      clusterRole:: {
        local kind = {kind: "ClusterRole"},
        default():: apiVersion + kind,
        // Rules holds all the PolicyRules for this ClusterRole
        rules(rules):: if std.type(rules) == "array" then {rules+: rules} else {rules: [rules]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // ClusterRoleBinding references a ClusterRole, but not contain it.  It can reference a ClusterRole in the global namespace, and adds who information via Subject.
      clusterRoleBinding:: {
        local kind = {kind: "ClusterRoleBinding"},
        default():: apiVersion + kind,
        // Subjects holds references to the objects the role applies to.
        subjects(subjects):: if std.type(subjects) == "array" then {subjects+: subjects} else {subjects: [subjects]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // RoleRef can only reference a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
          roleRef:: {
            local __roleRefMixin(roleRef) = {roleRef+: roleRef},
            // APIGroup is the group for the resource being referenced
            apiGroup(apiGroup):: __roleRefMixin({apiGroup: apiGroup}),
            // Name is the name of resource being referenced
            name(name):: __roleRefMixin({name: name}),
          },
        },
      },
      // ClusterRoleBindingList is a collection of ClusterRoleBindings
      clusterRoleBindingList:: {
        local kind = {kind: "ClusterRoleBindingList"},
        default():: apiVersion + kind,
        // Items is a list of ClusterRoleBindings
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // ClusterRoleList is a collection of ClusterRoles
      clusterRoleList:: {
        local kind = {kind: "ClusterRoleList"},
        default():: apiVersion + kind,
        // Items is a list of ClusterRoles
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // Role is a namespaced, logical grouping of PolicyRules that can be referenced as a unit by a RoleBinding.
      role:: {
        local kind = {kind: "Role"},
        default():: apiVersion + kind,
        // Rules holds all the PolicyRules for this Role
        rules(rules):: if std.type(rules) == "array" then {rules+: rules} else {rules: [rules]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // RoleBinding references a role, but does not contain it.  It can reference a Role in the same namespace or a ClusterRole in the global namespace. It adds who information via Subjects and namespace information by which namespace it exists in.  RoleBindings in a given namespace only have effect in that namespace.
      roleBinding:: {
        local kind = {kind: "RoleBinding"},
        default():: apiVersion + kind,
        // Subjects holds references to the objects the role applies to.
        subjects(subjects):: if std.type(subjects) == "array" then {subjects+: subjects} else {subjects: [subjects]},
        mixin:: {
          // Standard object's metadata.
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          // RoleRef can reference a Role in the current namespace or a ClusterRole in the global namespace. If the RoleRef cannot be resolved, the Authorizer must return an error.
          roleRef:: {
            local __roleRefMixin(roleRef) = {roleRef+: roleRef},
            // APIGroup is the group for the resource being referenced
            apiGroup(apiGroup):: __roleRefMixin({apiGroup: apiGroup}),
            // Name is the name of resource being referenced
            name(name):: __roleRefMixin({name: name}),
          },
        },
      },
      // RoleBindingList is a collection of RoleBindings
      roleBindingList:: {
        local kind = {kind: "RoleBindingList"},
        default():: apiVersion + kind,
        // Items is a list of RoleBindings
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
      // RoleList is a collection of Roles
      roleList:: {
        local kind = {kind: "RoleList"},
        default():: apiVersion + kind,
        // Items is a list of Roles
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  settings:: {
    v1alpha1:: {
      local apiVersion = {apiVersion: "settings/v1alpha1"},
      // PodPreset is a policy resource that defines additional runtime requirements for a Pod.
      podPreset:: {
        local kind = {kind: "PodPreset"},
        default():: apiVersion + kind,
        mixin:: {
          //
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
          //
          spec:: {
            local __specMixin(spec) = {spec+: spec},
            // Env defines the collection of EnvVar to inject into containers.
            env(env):: if std.type(env) == "array" then __specMixin({env+: env}) else __specMixin({env: [env]}),
            // EnvFrom defines the collection of EnvFromSource to inject into containers.
            envFrom(envFrom):: if std.type(envFrom) == "array" then __specMixin({envFrom+: envFrom}) else __specMixin({envFrom: [envFrom]}),
            // Selector is a label query over a set of resources, in this case pods. Required.
            selector:: {
              local __selectorMixin(selector) = __specMixin({selector+: selector}),
              // matchExpressions is a list of label selector requirements. The requirements are ANDed.
              matchExpressions(matchExpressions):: if std.type(matchExpressions) == "array" then __selectorMixin({matchExpressions+: matchExpressions}) else __selectorMixin({matchExpressions: [matchExpressions]}),
              // matchLabels is a map of {key,value} pairs. A single {key,value} in the matchLabels map is equivalent to an element of matchExpressions, whose key field is "key", the operator is "In", and the values array contains only "value". The requirements are ANDed.
              matchLabels(matchLabels):: __selectorMixin({matchLabels+: matchLabels}),
            },
            // VolumeMounts defines the collection of VolumeMount to inject into containers.
            volumeMounts(volumeMounts):: if std.type(volumeMounts) == "array" then __specMixin({volumeMounts+: volumeMounts}) else __specMixin({volumeMounts: [volumeMounts]}),
            // Volumes defines the collection of Volume to inject into the pod.
            volumes(volumes):: if std.type(volumes) == "array" then __specMixin({volumes+: volumes}) else __specMixin({volumes: [volumes]}),
          },
        },
      },
      // PodPresetList is a list of PodPreset objects.
      podPresetList:: {
        local kind = {kind: "PodPresetList"},
        default():: apiVersion + kind,
        // Items is a list of schema objects.
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
  storage:: {
    v1:: {
      local apiVersion = {apiVersion: "storage/v1"},
      // StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.
      //
      // StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
      storageClass:: {
        local kind = {kind: "StorageClass"},
        default():: apiVersion + kind,
        // Parameters holds the parameters for the provisioner that should create volumes of this storage class.
        parameters(parameters):: {parameters+: parameters},
        // Provisioner indicates the type of the provisioner.
        provisioner(provisioner):: {provisioner: provisioner},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // StorageClassList is a collection of storage classes.
      storageClassList:: {
        local kind = {kind: "StorageClassList"},
        default():: apiVersion + kind,
        // Items is the list of StorageClasses
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
    v1beta1:: {
      local apiVersion = {apiVersion: "storage/v1beta1"},
      // StorageClass describes the parameters for a class of storage for which PersistentVolumes can be dynamically provisioned.
      //
      // StorageClasses are non-namespaced; the name of the storage class according to etcd is in ObjectMeta.Name.
      storageClass:: {
        local kind = {kind: "StorageClass"},
        default():: apiVersion + kind,
        // Parameters holds the parameters for the provisioner that should create volumes of this storage class.
        parameters(parameters):: {parameters+: parameters},
        // Provisioner indicates the type of the provisioner.
        provisioner(provisioner):: {provisioner: provisioner},
        mixin:: {
          // Standard object's metadata. More info: https://github.com/kubernetes/community/blob/master/contributors/devel/api-conventions.md#metadata
          metadata:: {
            local __metadataMixin(metadata) = {metadata+: metadata},
            // Annotations is an unstructured key value map stored with a resource that may be set by external tools to store and retrieve arbitrary metadata. They are not queryable and should be preserved when modifying objects. More info: http://kubernetes.io/docs/user-guide/annotations
            annotations(annotations):: __metadataMixin({annotations+: annotations}),
            // The name of the cluster which the object belongs to. This is used to distinguish resources with same name and namespace in different clusters. This field is not set anywhere right now and apiserver is going to ignore it if set in create or update request.
            clusterName(clusterName):: __metadataMixin({clusterName: clusterName}),
            // Number of seconds allowed for this object to gracefully terminate before it will be removed from the system. Only set when deletionTimestamp is also set. May only be shortened. Read-only.
            deletionGracePeriodSeconds(deletionGracePeriodSeconds):: __metadataMixin({deletionGracePeriodSeconds: deletionGracePeriodSeconds}),
            // Must be empty before the object is deleted from the registry. Each entry is an identifier for the responsible component that will remove the entry from the list. If the deletionTimestamp of the object is non-nil, entries in this list can only be removed.
            finalizers(finalizers):: if std.type(finalizers) == "array" then __metadataMixin({finalizers+: finalizers}) else __metadataMixin({finalizers: [finalizers]}),
            // GenerateName is an optional prefix, used by the server, to generate a unique name ONLY IF the Name field has not been provided. If this field is used, the name returned to the client will be different than the name passed. This value will also be combined with a unique suffix. The provided value has the same validation rules as the Name field, and may be truncated by the length of the suffix required to make the value unique on the server.
            //
            // If this field is specified and the generated name exists, the server will NOT return a 409 - instead, it will either return 201 Created or 500 with Reason ServerTimeout indicating a unique name could not be found in the time allotted, and the client should retry (optionally after the time indicated in the Retry-After header).
            //
            // Applied only if Name is not specified. More info: http://releases.k8s.io/HEAD/docs/devel/api-conventions.md#idempotency
            generateName(generateName):: __metadataMixin({generateName: generateName}),
            // An initializer is a controller which enforces some system invariant at object creation time. This field is a list of initializers that have not yet acted on this object. If nil or empty, this object has been completely initialized. Otherwise, the object is considered uninitialized and is hidden (in list/watch and get calls) from clients that haven't explicitly asked to observe uninitialized objects.
            //
            // When an object is created, the system will populate this list with the current set of initializers. Only privileged users may set or modify this list. Once it is empty, it may not be modified further by any user.
            initializers:: {
              local __initializersMixin(initializers) = __metadataMixin({initializers+: initializers}),
              // Pending is a list of initializers that must execute in order before this object is visible. When the last pending initializer is removed, and no failing result is set, the initializers struct will be set to nil and the object is considered as initialized and visible to all clients.
              pending(pending):: if std.type(pending) == "array" then __initializersMixin({pending+: pending}) else __initializersMixin({pending: [pending]}),
              // If result is set with the Failure field, the object will be persisted to storage and then deleted, ensuring that other clients can observe the deletion.
              result:: {
                local __resultMixin(result) = __initializersMixin({result+: result}),
                // Suggested HTTP return code for this status, 0 if not set.
                code(code):: __resultMixin({code: code}),
                // Extended data associated with the reason.  Each reason may define its own extended details. This field is optional and the data returned is not guaranteed to conform to any schema except that defined by the reason type.
                details:: {
                  local __detailsMixin(details) = __resultMixin({details+: details}),
                  // The Causes array includes more details associated with the StatusReason failure. Not all StatusReasons may provide detailed causes.
                  causes(causes):: if std.type(causes) == "array" then __detailsMixin({causes+: causes}) else __detailsMixin({causes: [causes]}),
                  // The group attribute of the resource associated with the status StatusReason.
                  group(group):: __detailsMixin({group: group}),
                  // The name attribute of the resource associated with the status StatusReason (when there is a single name which can be described).
                  name(name):: __detailsMixin({name: name}),
                  // If specified, the time in seconds before the operation should be retried.
                  retryAfterSeconds(retryAfterSeconds):: __detailsMixin({retryAfterSeconds: retryAfterSeconds}),
                  // UID of the resource. (when there is a single resource which can be described). More info: http://kubernetes.io/docs/user-guide/identifiers#uids
                  uid(uid):: __detailsMixin({uid: uid}),
                },
                // A human-readable description of the status of this operation.
                message(message):: __resultMixin({message: message}),
                // A machine-readable description of why this operation is in the "Failure" status. If this value is empty there is no information available. A Reason clarifies an HTTP status code but does not override it.
                reason(reason):: __resultMixin({reason: reason}),
              },
            },
            // Map of string keys and values that can be used to organize and categorize (scope and select) objects. May match selectors of replication controllers and services. More info: http://kubernetes.io/docs/user-guide/labels
            labels(labels):: __metadataMixin({labels+: labels}),
            // Name must be unique within a namespace. Is required when creating resources, although some resources may allow a client to request the generation of an appropriate name automatically. Name is primarily intended for creation idempotence and configuration definition. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/identifiers#names
            name(name):: __metadataMixin({name: name}),
            // Namespace defines the space within each name must be unique. An empty namespace is equivalent to the "default" namespace, but "default" is the canonical representation. Not all objects are required to be scoped to a namespace - the value of this field for those objects will be empty.
            //
            // Must be a DNS_LABEL. Cannot be updated. More info: http://kubernetes.io/docs/user-guide/namespaces
            namespace(namespace):: __metadataMixin({namespace: namespace}),
          },
        },
      },
      // StorageClassList is a collection of storage classes.
      storageClassList:: {
        local kind = {kind: "StorageClassList"},
        default():: apiVersion + kind,
        // Items is the list of StorageClasses
        items(items):: if std.type(items) == "array" then {items+: items} else {items: [items]},
        mixin:: {
        },
      },
    },
  },
}
